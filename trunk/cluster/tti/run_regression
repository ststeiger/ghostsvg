#!/usr/bin/env python

# regression test dispatch script
# we can be used to launch a parallel regression
# this is a simplified version of the daemon scripts
# that do the automatic runs

import os, sys
import re, time

# PBS job server utilities

def choosecluster():
  '''Decide how many nodes of which cluster to run on.
     returns a (cluster_name, node_count) tuple.'''
  # figure out how many nodes are free
  r = re.compile('^\s+(?P<cluster>\w+).*\s+(?P<procs>\d+)\s+(?P<free>\d+)\s*$')
  clusters=[]
  nodes = 0
  upnodes = os.popen("upnodes")
  for line in upnodes.readlines():
    m = r.match(line)
    if m: 
      name = m.group("cluster")
      procs = int(m.group("procs"))
      free = int(m.group("free"))
      # remember the cluster with the most free nodes
      if free > nodes and not name in ('green', 'orange', 'total'): 
        nodes = free
        cluster = name
      clusters.append((name,procs,free))
  return (cluster, nodes)

def pbsjob(cmd, resources=None, stdout=None, stderr=None, mpi=True):
  if not resources:
    cluster, nodes = choosecluster()
    # 'green' nodes are now 64-bit. We build for 32-bit
    if nodes > 1 and cluster == 'red':		# or cluster == 'green':
      # red reports two cpus per node
      nodes /= 2
      ppn = ':ppn=2'
    else:
      ppn = ''
    if nodes > 20: nodes = 20
    # walltime doesn't limit job usage, cput does. Recent runs were about 6000 sec
    resources = 'nodes=%d:%s:run%s,cput=40000' % (nodes, cluster, ppn)
    print 'requesting', nodes, 'nodes on', cluster
  if stdout: jobname = stdout + '.pbs'
  else: jobname = 'regress.pbs'
  f = open(jobname, 'w')
  f.write('#PBS -l ' + resources)
  if stdout:
    f.write(' -o ' + stdout)
    if stdout == stderr:
      f.write(' -j oe')
    elif stderr:
      f.write(' -e ' + stderr)
  f.write(' -d ' + os.getcwd())
  f.write('\n\n')
  if mpi:
    f.write('mpiexec -comm mpich2-pmi ')
    f.write(' -nostdin -kill -nostdout')
    f.write(' ')
  f.write(cmd)
  f.write('\n')
  f.close()
  os.system('qsub ' + jobname)


# regression setup and reporting

def update(rev):
  'update the source to revision <rev>'
  svn = os.system("svn up -r" + rev)
  if svn:
    log("SVN update failed!")
    return False
  return True

def build(rev=None, target=None, clean=False):
  'compile an executable from the current source'
  if not rev:
    rev = "custom"
  if clean:
    if target == "pcl":
      # no autoconf on the PCL build
      cmd = "make clean && make"
    else:
      if os.path.exists('Makefile'):
        cmd = "make clean && ./autogen.sh && make"
      else:
        cmd = "./autogen.sh && make clean && make"
  else:
    if os.path.exists('Makefile'):
      cmd = "make"
    else:
      cmd = "./autogen.sh && make"
  if False:
    # build on the dispatch host
    make = os.system(cmd)
    make = make >> 8
  else:
    # build on a compile node
    resources = 'nodes=1:build32'
    report = 'build-' + rev + '.log'
    if os.path.exists(report): os.unlink(report)
    make = pbsjob(cmd, resources, stdout=report, stderr=report, mpi=False)
    while not os.path.exists(report):
      time.sleep(5)
  if make:
    log("build failed! exit code " + str(make))
    return False
  # update successful
  return True

def usage(name=sys.argv[0]):
  print "Usage: %s" % name
  print "launch a regression run on tticluster.com"
  print "testing the gs build in the current directory"
  print "against the default baseline"

def log(msg):
  print '[' + time.ctime() + '] ' + msg

def gettarget():
  '''Guess whether we're doing Ghostscript for GhostPCL'''
  if os.path.exists("main/pcl6_gcc.mak"): return "pcl"
  elif os.path.exists("psi/gs.c"): return "gs"
  elif os.path.exists("src/gs.c"): return "gs"
  else: return None

def runrev(rev=None, report=None, target=None):
  if not report: report = "regression-r" + rev + ".log"
  if not target: target = gettarget()
  log("running custom regression " + rev)
  start = time.time()
  # remove the report if it exists since we use this to check completion
  if os.path.exists(report): os.unlink(report)
  log("building...")
  print "looks like the target is", target
  if not build(rev, target=target, clean=True):
    log("Build failed!",rev)
  else:
    log("build finished.")
    log("starting tests...")
    cmd = 'bwpython ~/regression/regress.py --batch --update'
    if target == "pcl":
      cmd += ' --exe main/obj/pcl6'
      cmd += ' --device=ppmraw --device=pbmraw --device=wtsimdi --device=bitrgb'
    else:
      cmd += ' --device=ppmraw --device=pbmraw --device=pkmraw'
    pbsjob(cmd, resources=None, stdout=report)
    # wait for the run to finish
    while not os.path.exists(report):
      time.sleep(20)
    os.system("cat " + report + " | grep NEW")
    os.system("cat " + report + " | grep PASSED")
    os.system("cat " + report + " | grep FAILED")
    os.system("cat " + report + " | grep ERROR")
    print "report is ready as '" + report + "'. total time %d seconds" % int(time.time() - start)
    log("tests complete.")

def mainloop():
  log("starting up")
  rev = str(int(time.time()))
  report = "regression-" + rev + ".log"
  runrev(rev, report)

if __name__ == '__main__':
    mainloop()
