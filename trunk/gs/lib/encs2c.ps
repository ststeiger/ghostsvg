%!
%    Copyright (C) 2002 Aladdin Enterprises.  All rights reserved.
% 
% This software is provided AS-IS with no warranty, either express or
% implied.
% 
% This software is distributed under license and may not be copied,
% modified or distributed except as expressly authorized under the terms
% of the license contained in the file LICENSE in this distribution.
% 
% For more information about licensing, please refer to
% http://www.ghostscript.com/licensing/. For information on
% commercial licensing, go to http://www.artifex.com/licensing/ or
% contact Artifex Software, Inc., 101 Lucas Valley Road #110,
% San Rafael, CA  94903, U.S.A., +1(415)492-9861.

% $Id$
% Generate a C file containing the standard encodings and glyph sets.

% This program probably never needs to be run again: it is included mostly
% for reference.  It reads in the known Encodings and pseudo-Encodings
% (see the definition of /encfiles below) and generates a C file that
% represents them in a compact format described in src/gscencs.c.
% The generated file is named gscedata.c and is included in the source
% distribution in the src directory.  The canonical invocation is
%	gs -dNODISPLAY -q lib/encs2c.ps > src/gscedata.c

% NOTE: If the representation produced by this file changes, this file
% (lib/encs2c.ps), src/gscencs.h, and src/gscencs.c must be kept consistent.

% Collect the registered encodings.

/encodings 20 array def
/encfiles [
  [(gs_std_e.ps) (gs_il1_e.ps) (gs_sym_e.ps) (gs_dbt_e.ps)]
  [(gs_wan_e.ps) (gs_mro_e.ps) (gs_mex_e.ps) (gs_mgl_e.ps)]
  [(gs_lgo_e.ps) (gs_lgx_e.ps) (gs_css_e.ps)]
] def
4 dict begin
/.registerencoding {
  //encodings 3 1 roll readonly put
} bind def
encfiles { { runlibfile } forall } forall
end
/encodings [ encodings { dup null eq { pop } if } forall ] def

% Collect all names referenced from the encodings.
/estrs 1000 dict def
/maxlen 0 def
/numchars 0 def
encodings {
  {
    estrs 1 index null put
    .namestring length maxlen .max /maxlen exch def
  } forall
} forall

% Do assignments until the process converges.
/maxlencode 3 def	% adhoc, must be small
/checksub {	% <str> <delta> checksub -
	% Free variables: estrs, offset
  estrs 2 index known {
    estrs 2 index offset 3 index add put
  } if pop pop
} def
/checkallsub {	% <str> checkallsub -
	% Check for re-using prefixes and suffixes.
	% Free variables: len, maxdirect
  1 1 len 1 sub maxdirect .min {
	% Stack: namestr sublen
    2 copy 0 exch getinterval 0 checksub
    1 index 3 1 roll len 1 index sub exch 1 index
	% Stack: namestr namestr len-sublen sublen len-sublen
    4 1 roll getinterval exch checksub
  } for
} def
{
  estrs { pop estrs exch null put } forall
  /numchars 0 def
  /offset 0 def
  /maxdirect maxlencode 1 sub def
  maxlen -1 1 {
    /len exch def estrs {
      null eq {
	.namestring dup length len eq {
	  dup checkallsub
	  length offset add /offset exch def
	} {
	  pop
	} ifelse
      } if
    } forall
  } for
  /numchars offset def
  65535 numchars idiv
  dup maxlencode eq { pop exit } if
  /maxlencode exch def  
} loop
estrs { pop estrs exch null put } forall

% Write the initial boilerplate.
(/*) =
( * Copyright (C) 2002 artofcode LLC.  All rights reserved.) =
( * See gscencs.h for the complete license notice.) =
( *) =
( * This file contains substantial parts of encs2c.ps, which generated) =
( * the remainder of the file mechanically from) =
encfiles {
  ( * ) print { (  ) print print } forall () =
} forall
( */) =
() =
(#define MAX_DIRECT_LEN ) print maxdirect =
(#define NUM_INDIRECT_LEN ) print maxlen maxdirect sub =
(#define NUM_CHARS ) print numchars =

% Write the name strings, sorted by decreasing length, and alphabetically
% increasing within the same length.
/printname {	% <string> printname -
    (I_) print
    dup 0 get (.) 0 get eq { (_) print dup length 1 sub 1 exch getinterval } if
    print
} def
(
static const char gs_c_std_encoding_chars[] = {) =
/offset 0 def
/lbase maxlen 1 add array def
/olds maxlen 1 add array def
maxlen -1 1 {
  /len exch def
  lbase len offset put
	% Collect names of this length that have[n't] already been assigned.
	% Note that if len > maxdirect, old will be empty.
  /new [ estrs {
    null ne 1 index length len ne or { pop } { .namestring } ifelse
  } forall ] /lt load .sort def
  /old [ estrs {
    null eq 1 index length len ne or { pop } { .namestring } ifelse
  } forall ] /lt load .sort def
	% Output the new names.
  new {
    dup {
      (') print (x) dup 0 4 -1 roll put print (',) print
    } forall () =
    checkallsub
    offset /offset offset len add def
    (#define ) print exch printname
    len maxdirect le {
      ( N\() print
    } {
      ( NX\() print
      lbase len get sub len idiv
    } ifelse len =only (,) print =only (\)) =
  } forall
	% Output the definitions of the old names.
  old {
    (#define ) print dup printname    
    ( N\() print len =only (,) print estrs exch get =only (\)) =
  } forall
  olds len old put
} for
(0};) =

% Write the sorted old short names.
/starts maxdirect 1 add array def
/offset 0 def
(
static const ushort gs_c_sorted_short[] = {) =
maxdirect -1 1 {
  /len exch def
  starts len offset put
  olds len get dup { printname (,) print } forall () =
  length offset add /offset exch def
} for
(0};) =
starts 0 offset put
(
static const uint gs_c_sorted_starts[] = {) =
starts 0 maxdirect getinterval { =only (,) print } forall
(0};) =

% Write the starting offsets of the names of each length.
(
static const uint gs_c_std_encoding_offsets[] = {) =
numchars =only
1 1 maxlen {
  (,) print lbase exch get =only
} for
(};) =

% Write the encodings themselves.
/i 0 def
encodings {
  () =
  (static const ushort gs_c_std_encoding_) print i =only ([] = {) =
	% Encode runs of .notdef followed by runs of defined characters.
	% To reduce the number of runs, only encode runs of at least
	% two consecutive .notdefs.
  /e exch def /len e length def /j 0 def {
    j len ge { exit } if /notdj j def {
      j len ge { exit } if e j get /.notdef ne { exit } if
      /j j 1 add def
    } loop /dj j def {
      j len ge { exit } if e j get /.notdef eq {
	j 1 add len lt {
	  e j 1 add get /.notdef eq { exit } if
	} if
      } if
      /j j 1 add def
    } loop
    (C\() print dj notdj sub =only (,) print j dj sub =only (\), ) print
    dj 1 j 1 sub {
      e exch get .namestring printname (, ) print
    } for
  } loop (0};) =
  /i i 1 add def
} forall

% Write the table of pointers to the encodings.
(
static const ushort *const gs_c_std_encodings[] = {) =
0 1 encodings length 1 sub {
  (    gs_c_std_encoding_) print =only (,) =
} for (    0
};) =

quit
