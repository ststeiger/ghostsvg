%!PS-Adobe-2.0
%
%	 Copyright (C) 2002 artofcode LLC.	All rights reserved.
% 
% This software is provided AS-IS with no warranty, either express or
% implied.
% 
% This software is distributed under license and may not be copied,
% modified or distributed except as expressly authorized under the terms
% of the license contained in the file LICENSE in this distribution.
% 
% For more information about licensing, please refer to
% http://www.ghostscript.com/licensing/. For information on
% commercial licensing, go to http://www.artifex.com/licensing/ or
% contact Artifex Software, Inc., 101 Lucas Valley Road #110,
% San Rafael, CA  94903, U.S.A., +1(415)492-9861.

% $Id$
% pdfread.ps - A procset for interpreting an ordered PDF 1.3 file.

% This module defines routines for interpreting a PDF file with
% a Postscript interpreter. To convert a PDF file into Postscript 
% just pre-contcatenate this file. The PDF file must satisfy 
% few constraints :
%
% 1. It must contain only Postscript level 2 objects encoded with
% the PDF 1.3 language. Higher PDF levels must be re-distilled
% with CompatibilityLevel=1.3 .
%
% 2. Objects must be ordered so that any resource be defined before
% its usage.
%
% 3. The PDF file must not include other PDF files.
% Consequently we have a single instance of the PDF reader.
% We use this fact to simplify binding of the routines.
% 
% 4. The PDF root object must always have the object id 1.
% 
% 5. Generations besides 0 are not allowed.
%
% 6. xref must appear after all objects.
%
% Assuming the currentfile isn't positionable.
% As a consequence, the reader fully ignores xref.


% !!!!!!!!!!!!!  THIS REVISION IS INCOMPLETE !!!!!!!!!!!!!!!!!!!!
% It only reads a PDF, but it does not do any attempt to interprete it.


true setglobal
30 dict begin

% ===================== Debugging =========================================

/DefaultSwitch	% <name> DefaultSwitch -
{
  dup where {
	pop pop
  } {
	false def
  } ifelse
} bind def

/=string 256 string def

/=only {
  //=string cvs print
} bind def

/PDFR_DEBUG DefaultSwitch
/PDFR_DUMP DefaultSwitch
/PDFR_STREAM DefaultSwitch

/error	%  mark <object> .... error -
{ % A stub for a while.
  counttomark 1 sub -1 0 {
	index =only
  } for
  (\nostack contains :) =
  cleartomark
  % Assuming ....Undefined is never defined. 
  % Use it to emit an error.
  ....Undefined
} bind def

% ===================== Work Data =========================================

/BlockBuffer 4096 string def
/PDFReader currentdict def
/ObjectRegistry 50 array def % may grow later
/CurrentObject null def
/DoneDocumentStructure false def

% ===================== Reading PDF objects ===============================

/Register % <DefaultDaemon> <id> <obj> Register -
{
  exch dup															% d obj id id
  //PDFReader /ObjectRegistry get length gt {
	//PDFReader /ObjectRegistry get length dup dup 2 div add array	% d obj id length []
	dup 3 1 roll													% d obj id [] length []
	exch 0 exch getinterval 										% d obj id [] []
	//PDFReader /ObjectRegistry get exch copy pop					% d obj id []
	//PDFReader /ObjectRegistry exch put							% d obj id
  } if
  exch //PDFReader /ObjectRegistry get								% d id obj r
  3 1 roll															% d r id obj
  3 copy pop get													% d r id obj e
  dup xcheck {														% d r id obj e
	5 4 roll pop													% r id obj e
	% We've got a definition daemon, execute it :
	exec
  } {																% d r id obj e
	  dup null ne { 												% d r id obj e
		mark (The object ) 4 index ( already defined : ) 4 index //error exec
	} {
	  pop
	} ifelse
	4 3 roll														% r id obj d
	% Execute the default daemon :
	exec
  } ifelse															% r id obj
  put																%
} bind def

/GetRegistered % <id> GetRegistered <obj>
{
  //PDFReader /ObjectRegistry get									% id r
  dup length														% id r l
  2 index le {														% id r
	exch mark exch (Object ) exch ( isn't defined before needed (1).) //error exec 
  } if
  1 index get														% id e
  dup xcheck {
	exch mark exch (Object ) exch ( isn't defined before needed (2).) //error exec 
  } { dup null eq {
		exch mark exch (Object ) exch ( isn't defined before needed (3).) //error exec 
	  } if
	  exch pop														% e
  } ifelse

} bind def

/R % <id> <gen> R <daemon>
{ % Make a reference daemon.
  0 ne {
	exch mark exch (A referred object generation ) exch ( isn't 0.) //error exec
  } if																% id
  [ % <id> proc <obj>
	exch //GetRegistered /exec load 
  ] cvx
  PDFR_DEBUG {
	({ ) print
	dup {
	  =only ( ) print
	} forall
	( }) =
  } if
} bind def

/DoNothing 
{
} def

/RunTypeDaemon  % <id> <obj> RunTypeDaemon <id> <obj>
{
  dup type /dicttype eq {
    dup /Type known { 
      dup /Type get
        //PDFReader /TypeDaemons get exch
	    2 copy known {
		  get exec
		} {
		  pop pop
		} ifelse
    } if
  } if
} bind def

/obj % <id> <generation> obj <id>
{
  PDFR_DEBUG {
	(Defining ) print 1 index =only ( ) print dup =only ( obj) =
  } if
  0 ne {
	exch mark exch (An object generation ) exch ( isn't 0.) //error exec
  } if
} bind def

/endobj  % <id> <obj> endobj -
{
  PDFR_DEBUG {
	(Storing ) print 1 index =
  } if
  //RunTypeDaemon exec
  //DoNothing 3 1 roll //Register exec
} bind def

/StoreBlock % <buf> StoreBlock -
{ % Stores a (encoded) stream data block to the current object.
  PDFR_DEBUG {
	(StoreBlock ) print //PDFReader /BlockCount get =only (, Length = ) print dup length =
  } if
  dup length string copy
  //PDFReader /BlockCount get exch									% i s
  //PDFReader /CurrentObject get 3 1 roll							% o i s
  put																%
  //PDFReader /BlockCount get 1 add
  //PDFReader exch /BlockCount exch put
} bind def

/CheckLength % <val> CheckNumber <val>
{ dup type /integertype ne {
	mark (Object length isn't an integer.) //error exec
  } if
} bind def

/UnRefD % <dict> <key> <check> UnRefD <value>
{
  3 copy pop get													% <> key {} e
  dup xcheck {
	% We've got a reference daemon, execute it :
	exec															% <> key {} val
  } if
  exch exec 														% <> key val
  dup 4 1 roll														% val <> key val
  put																% val
} bind def

/StoreStream  % <id> <obj> StoreStream <id> <obj>
{ % Stores a (encoded) data stream copy to the current object.
  dup //PDFReader exch /CurrentObject exch put						% id obj
  //PDFReader /BlockCount 0 put
  dup /Length //CheckLength //UnRefD exec							% id obj l
  PDFR_DEBUG {
	(StoreStream Length = ) print dup =
  } if
  currentfile exch () /SubFileDecode filter 						% id obj file
  { dup //BlockBuffer readstring {									% id obj file buf
	  //StoreBlock exec
	} {
	  //StoreBlock exec
	  exit
	} ifelse														% id obj file
  } loop
  pop																% id obj
  //PDFReader /CurrentObject null put
  PDFR_DEBUG {
	(StoreStream end.) =
  } if
} bind def

/ExecuteStream  % <id> <obj> ExecuteStream <id> <obj>
{ % Executes a (encoded) data stream.
  dup /Length //CheckLength //UnRefD exec							% id obj l
  PDFR_DEBUG {
	(ExecuteStream id = ) print 2 index =only ( Length = ) print dup =
  } if
  //PDFReader /Operators get begin
  currentfile exch () /SubFileDecode filter 						% id obj file
  cvx mark exch														% id obj mark file
  exec
  counttomark 0 ne {
    mark (Data left on ostack after a stream execution) //error exec
  } if
  cleartomark														% id obj
  end % Operators
  PDFR_DEBUG {
	(ExecuteStream end.) =
  } if
} bind def

/stream  % <id> <obj> stream <id> <obj>
{ 
  PDFR_DEBUG {
	1 index =only ( stream) =
  } if																% id obj
  % Run the object definition daemon, if exists :
  //PDFReader /ObjectRegistry get dup length 3 index                % id obj r l id
  gt {																% id obj r
    2 index get 
	dup xcheck {
	  exec
	  % Disable the daemon :
      //PDFReader /ObjectRegistry get 2 index null put
	} {
	  pop
	} ifelse
  } {
    pop
  } ifelse															% id obj
  dup /ImmediateExec known {
	//ExecuteStream exec
  } {
	//StoreStream exec
  } ifelse
} bind def

/endstream % <id> <obj> endstream <id> <obj>
{ % Nothing to do.
} bind def

/xref % - xref -
{ 
  PDFR_DEBUG {
	(xref) =
	PDFR_DUMP {
	  //PDFReader /ObjectRegistry get ==
	} if
  } if
  end % The procset
  count 0 ne {
	mark (Excessive data on estack at the end of the interpretation.) //error exec
  } if
  currentfile flushfile
} bind def

% ===================== Restoring the PDF Document Structure ===============

/PageContentsDaemon % <id> <obj> <node> PageContentsDaemon <id> <obj>
{ % Note: an excessive operand from a prebond procedure.
  PDFR_DEBUG {
	(Executing PageContentsDaemon for ) print 2 index =
  } if																% id obj node
  1 index exch /Context exch put									% id obj
  dup /ImmediateExec true put
} bind def

/TypeDaemons <<  % <id> <obj> proc <id> <obj>
  /Page 
  { PDFR_DEBUG {
	  (Recognized a page.)=
	} if
	dup /Contents get 0 get	//DoNothing exch 						% id obj dn id1
	[ % <id> <obj> proc <id> <obj>
	  3 index //PageContentsDaemon /exec load
	] cvx															% id obj {}
	//Register exec													% id obj
  } bind
>> def

% ===================== Interpret Data Streams ===============

/TempMatrix matrix def

/Operators 50 dict begin
  /q /gsave load def
  /Q /grestore load def
  /cm { //TempMatrix astore concat } bind def
  /i { 1 .min setflat } bind def
  /J /setlinecap load def
  /d /setdash load def
  /j /setlinejoin load def
  /w /setlinewidth load def
  /M /setmiterlimit load def
  /gs { (Unimplemented SetExtGState)= pop } bind def

  /g /setgray load def
  /rg /setrgbcolor load def
  /k /setcmykcolor load def
  /cs { ResolveColorSpace setcolorspace } bind def
  /sc /setcolor load def
  /scn  /setcolor load def
  /G /setgray load def
  /RG /setrgbcolor load def
  /K /setcmykcolor load def
  /CS { ResolveColorSpace setcolorspace } bind def
  /ri { SetColorRenderingIntent } bind def
  /SC /setcolor load def
  /SCN /setcolor load def

  /m /moveto load def
  /l /lineto load def
  /c /curveto load def
  /v { currentpoint 6 2 roll curveto } def
  /y { 2 copy curveto } def
  /re {
   4 2 roll moveto  exch dup 0 rlineto  0 3 -1 roll rlineto  neg 0 rlineto
   closepath
  } def
  /h /closepath load def
  /n /newpath load def
  /S /stroke load def
  /s { closepath stroke } bind def
  /f /fill load def
  /f* /eofill load def
  /B { gsave fill grestore stroke } bind def
  /b { closepath gsave fill grestore stroke } bind def
  /B* { gsave eofill grestore stroke } bind def
  /b* { closepath gsave eofill grestore stroke } bind def
  /W /clip load def
  /W* /eoclip load def
  /sh { ResolveShading shfill } bind def

  /DO { DoXObject } bind def

  /BI { BeginIfnlineImage } bind def
  /EI { EndInlineImage } bind def
  /ID { BeginInlineData } bind def

  /BT { (Unimplemented BeginText)= } bind def
  /ET { (Unimplemented EndText)= } bind def
  /Tc { SetCharacterSpacing } bind def
  /TL { SetTextLeading } bind def
  /Tr { SetTextRenderingMode } bind def
  /Ts { SetTextRise } bind def
  /Tw { SetWordSpacing } bind def
  /Tz { SetHorizontalTextScaling } bind def
  /Td { (Unimplemented MoveTextPosition)= pop pop } bind def
  /TD { MoveTextPositionAndSetLeading } bind def
  /Tm { (Unimplemented SetTextMatrixAndTextLineMatrix)= pop pop pop pop pop pop } bind def
  /T* { MoveToNextTextLine } bind def
  /Tj { (Unimplemented ShowText)= pop } bind def
  /' { MoveToNextTextLine ShowText } bind def
  /" { SetWordSpacing SetCharacterSpacing MoveToNextTextLine ShowText } bind def
  /TJ { (Unimplemented ShowTextWithGlyphPositioning)= pop } bind def
  /Tf { (Unimplemented SetFont)= pop pop } bind def

  /d0 /setcharwidth load def
  /d1 /setcachedevice load def

  /BDC { BeginMarkedContentSequenceWithPropertyList } bind def
  /BMC { BeginMarkedContentSequence } bind def
  /EMC { EndMarkedContentSequence } bind def
  /BX { BeginCompatibilitySection } bind def
  /DP { DefineMarkedContentPointWithPropertyList } bind def
  /MP { DefineMarkedContentPoint } bind def
currentdict end def

PDFR_STREAM {
  % Rebind operators with a debug tracing.
  //Operators length dict begin
  //Operators {												% n p
	exch dup												% p n n
	[ exch //=only /exec load								% p n [ n =only exec
	  ( ) /print load										% p n [ n =only exec () print
      8 7 roll												% n [ n =only exec () print p
	  dup type /arraytype eq {
	    /exec load											% n [ n =only exec () print p exec
	  } if
	  ( ) /print load
	] cvx													% n {}
	def
  } forall
  currentdict end /Operators exch def
} if

% Leaving the procset on the dictionary stack to provide 
% definitions of obj, endobj, stream, endstream, R, xref.
%%EndPrologue
