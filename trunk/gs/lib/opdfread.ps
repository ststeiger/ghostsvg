%!PS-Adobe-2.0
%
%	 Copyright (C) 2002 artofcode LLC.	All rights reserved.
% 
% This software is provided AS-IS with no warranty, either express or
% implied.
% 
% This software is distributed under license and may not be copied,
% modified or distributed except as expressly authorized under the terms
% of the license contained in the file LICENSE in this distribution.
% 
% For more information about licensing, please refer to
% http://www.ghostscript.com/licensing/. For information on
% commercial licensing, go to http://www.artifex.com/licensing/ or
% contact Artifex Software, Inc., 101 Lucas Valley Road #110,
% San Rafael, CA  94903, U.S.A., +1(415)492-9861.

% $Id$
% pdfread.ps - A procset for interpreting an ordered PDF 1.3 file.

% This module defines routines for interpreting a PDF file with
% a Postscript interpreter. To convert a PDF file into Postscript 
% just pre-contcatenate this file. The PDF file must satisfy 
% few constraints :
%
% 1. It must contain only Postscript level 2 objects encoded with
% the PDF 1.3 language. Higher PDF levels must be re-distilled
% with CompatibilityLevel=1.3 .
%
% 2. Objects must be ordered so that any resource be defined before
% its usage.
%
% 3. The PDF file must not include other PDF files.
% Consequently we have a single instance of the PDF reader.
% We use this fact to simplify binding of the routines.
% 
% 4. The PDF root object must always have the object id 1.
% 
% 5. Generations besides 0 are not allowed.
%
% 6. xref must appear after all objects.
%
% Assuming the currentfile isn't positionable.
% As a consequence, the reader fully ignores xref.


% !!!!!!!!!!!!!  THIS REVISION IS INCOMPLETE !!!!!!!!!!!!!!!!!!!!
% It only reads a PDF, but it does not do any attempt to interprete it.


true setglobal
30 dict begin

% ===================== Debugging =========================================

/DefaultSwitch	% <name> DefaultSwitch -
{
  dup where {
	pop pop
  } {
	false def
  } ifelse
} bind def

/=string 256 string def

/=only {
  //=string cvs print
} bind def

/PDFR_DEBUG DefaultSwitch
/PDFR_DUMP DefaultSwitch
/PDFR_STREAM DefaultSwitch

/error	%  mark <object> .... error -
{ % A stub for a while.
  counttomark 1 sub -1 0 {
	index dup type /arraytype eq { == } { =only } ifelse
  } for
  () =
  cleartomark
  % Assuming ....Undefined is never defined. 
  % Use it to emit an error.
  ....Undefined
} bind def

% ===================== Utilities =========================================

/knownget % <dict> <key> knownget <value> true
          % <dict> <key> knownget false
{
  2 copy known {
    get true
  } {
    pop pop false
  } ifelse
} bind def

/IsUpper  % <int> IsUpper <bool>
{ dup (A) 0 get ge exch (Z) 0 get le and
} bind def

% ===================== Work Data =========================================

/BlockBuffer 4096 string def
/PDFReader currentdict def
/ObjectRegistry 50 array def % may grow later
/CurrentObject null def
/DoneDocumentStructure false def
/GraphicState 20 dict begin
  /InitialTextMatrix matrix def
currentdict end def
/TempMatrix matrix def
/GraphicStateStack 20 array def
/GraphicStateStackPointer 0 def
/PDFColorSpaces 50 dict def

% We need some structures in local VM, put then into the userdict :
currentglobal false setglobal
userdict /PDFR_InitialGS gstate put
userdict /PDFR_Patterns 50 dict put
setglobal

% ===================== Constants =========================================

/InitialExtGState 20 dict begin
  /BG2 currentblackgeneration def
  /UCR2 currentundercolorremoval def
  /TR2 [ currentcolortransfer ] def
  /HT currenthalftone def
currentdict end readonly def

/InitialGraphicState 20 dict begin
  /FontSize 0 def
  /CharacterSpacing 0 def
  /TextLeading 0 def
  /TextRenderingMode 0 def
  /WordSpacing 0 def
currentdict end readonly def

% ===================== Reading PDF objects ===============================

/Register % <DefaultDaemon> <id> <obj> Register -
{
  exch dup															% d obj id id
  //PDFReader /ObjectRegistry get length ge {
	dup dup 2 idiv add array dup									% d obj id [n] [n]
	//PDFReader /ObjectRegistry get dup	length						% d obj id [n] [n] [o] l
	3 2 roll exch													% d obj id [n] [o] [n] l
	0 exch getinterval copy pop										% d obj id [n]
	//PDFReader exch /ObjectRegistry exch put						% d obj id
  } if
  exch //PDFReader /ObjectRegistry get								% d id obj r
  3 1 roll															% d r id obj
  3 copy pop get													% d r id obj e
  dup xcheck {														% d r id obj e
	5 4 roll pop													% r id obj e
	% We've got a definition daemon, execute it :
	exec
  } {																% d r id obj e
	  dup null ne { 												% d r id obj e
		mark (The object ) 4 index ( already defined : ) 4 index //error exec
	} {
	  pop
	} ifelse
	4 3 roll														% r id obj d
	% Execute the default daemon :
	exec
  } ifelse															% r id obj
  put																%
} bind def

/GetRegistered % <id> GetRegistered <obj>
{
  //PDFReader /ObjectRegistry get									% id r
  dup length														% id r l
  2 index le {														% id r
	exch mark exch (Object ) exch ( isn't defined before needed (1).) //error exec 
  } if
  1 index get														% id e
  dup xcheck {
	exch mark exch (Object ) exch ( isn't defined before needed (2).) //error exec 
  } { dup null eq {
		exch mark exch (Object ) exch ( isn't defined before needed (3).) //error exec 
	  } if
	  exch pop														% e
  } ifelse

} bind def

/PrintReference % <array> PrintReference <array>
{
  //PDFR_DEBUG {
	({ ) print
	dup {
	  =only ( ) print
	} forall
	( }) =
  } if
} bind def

/R % <id> <gen> R <daemon>
{ % Make a reference daemon.
  0 ne {
	exch mark exch (A referred object generation ) exch ( isn't 0.) //error exec
  } if																% id
  [ % <id> proc <obj>
	exch //GetRegistered /exec load 
  ] cvx
  //PrintReference exec
} bind def

/DoNothing 
{
} def

/RunTypeDaemon  % <id> <obj> RunTypeDaemon <id> <obj>
{
  dup type /dicttype eq {
    dup /Type //knownget exec {
      //PDFReader /TypeDaemons get exch
	  //knownget exec {
	    exec
	  } if
	} if
  } if
} bind def

/obj % <id> <generation> obj <id>
{
  //PDFR_DEBUG {
	(Defining ) print 1 index =only ( ) print dup =only ( obj) =
  } if
  0 ne {
	exch mark exch (An object generation ) exch ( isn't 0.) //error exec
  } if
} bind def

/endobj  % <id> <obj> endobj -
{
  //PDFR_DEBUG {
	(Storing ) print 1 index =
  } if
  //RunTypeDaemon exec
  //DoNothing 3 1 roll //Register exec
} bind def

/StoreBlock % <buf> StoreBlock -
{ % Stores a (encoded) stream data block to the current object.
  //PDFR_DEBUG {
	(StoreBlock ) print //PDFReader /BlockCount get =only (, Length = ) print dup length =
  } if
  dup length string copy
  //PDFReader /BlockCount get exch									% i s
  //PDFReader /CurrentObject get 3 1 roll							% o i s
  put																%
  //PDFReader /BlockCount get 1 add
  //PDFReader exch /BlockCount exch put
} bind def

/CheckLength % <val> CheckNumber <val>
{ dup type /integertype ne {
	mark (Object length isn't an integer.) //error exec
  } if
} bind def

/ResolveD % <dict> <key> <check> ResolveD <value>
{
  3 copy pop get													% <> key {} e
  dup xcheck {
	% We've got a reference daemon, execute it :
	//PDFR_DEBUG {
	  (Resolving ) print //PrintReference exec
	} if
	exec															% <> key {} val
    exch exec 														% <> key val
  } {
    exch pop
  } ifelse
  dup 4 1 roll														% val <> key val
  put																% val
} bind def

/StoreStream  % <id> <obj> StoreStream <id> <obj>
{ % Stores a (encoded) data stream copy to the current object.
  dup //PDFReader exch /CurrentObject exch put						% id obj
  //PDFReader /BlockCount 0 put
  dup /Length //CheckLength //ResolveD exec							% id obj l
  //PDFR_DEBUG {
	(StoreStream Length = ) print dup =
  } if
  currentfile exch () /SubFileDecode filter 						% id obj file
  { dup //BlockBuffer readstring {									% id obj file buf
	  //StoreBlock exec
	} {
	  //StoreBlock exec
	  exit
	} ifelse														% id obj file
  } loop
  pop																% id obj
  //PDFReader /CurrentObject null put
  //PDFR_DEBUG {
	(StoreStream end.) =
  } if
} bind def

/ExecuteStream  % <id> <obj> ExecuteStream <id> <obj>
{ % Executes a (encoded) data stream.
  dup //PDFReader exch /CurrentObject exch put						% id obj
  dup /Length //CheckLength //ResolveD exec							% id obj l
  //PDFR_DEBUG {
	(ExecuteStream id = ) print 2 index =only ( Length = ) print dup =
  } if
  //PDFReader /InitialGraphicState get 
  //PDFReader /GraphicState get copy pop
  //PDFReader /Operators get begin
  currentfile exch () /SubFileDecode filter 						% id obj file
  cvx mark exch														% id obj mark file
  exec
  counttomark 0 ne {
    mark (Data left on ostack after an immediate stream execution.) //error exec
  } if
  cleartomark														% id obj
  end % Operators
  //PDFR_DEBUG {
	(ExecuteStream end.) =
  } if
  //PDFReader /CurrentObject null put
  showpage
} bind def

/stream  % <id> <obj> stream <id> <obj>
{ 
  //PDFR_DEBUG {
	1 index =only ( stream) =
  } if																% id obj
  % Run the object definition daemon, if exists :
  //PDFReader /ObjectRegistry get dup length 3 index                % id obj r l id
  gt {																% id obj r
    2 index get 
	dup xcheck {
	  exec
	  % Disable the daemon :
      //PDFReader /ObjectRegistry get 2 index null put
	} {
	  pop
	} ifelse
  } {
    pop
  } ifelse															% id obj
  dup /ImmediateExec known {
	//ExecuteStream exec
  } {
	//StoreStream exec
  } ifelse
} bind def

/endstream % <id> <obj> endstream <id> <obj>
{ % Nothing to do.
} bind def

/xref % - xref -
{ 
  //PDFR_DEBUG {
	(xref) =
	//PDFR_DUMP {
	  //PDFReader /ObjectRegistry get ==
	} if
  } if
  end % The procset
  count 0 ne {
	mark (Excessive data on estack at the end of the interpretation.) //error exec
  } if
  currentfile flushfile
} bind def

% ===================== Restoring the PDF Document Structure ===============

/ResolveDict  % <dict> /ResolveDict -
{ dup {															% d key val
    pop 1 index exch											% d cp key
	//DoNothing //ResolveD exec									% d obj
	pop															% d
  } forall
  pop															%
} bind def

/PageContentsDaemon % <id> <obj> <node> PageContentsDaemon <id> <obj>
{ % Note: an excessive operand from a prebond procedure.
  //PDFR_DEBUG {
	(Executing PageContentsDaemon for ) print 2 index =
  } if																% id obj node
  1 index exch /Context exch put									% id obj
  dup /ImmediateExec true put
} bind def

/TypeDaemons <<  % <id> <obj> proc <id> <obj>
  /Page 
  { //PDFR_DEBUG {
	  (Recognized a page.)=
	} if
	dup /Contents //knownget exec {
	  0 get	//DoNothing exch 										% id obj dn id1
	  [ % <id> <obj> proc <id> <obj>
	    3 index //PageContentsDaemon /exec load
	  ] cvx															% id obj {}
	  //Register exec												% id obj
    } {
      (fixme: page with no Contents won't be printed.) =
    } ifelse
  } bind
>> def

/MakeStreamReader % <obj> MakeStreamReader <file>
{ [ 
    exch
	//PDFR_DEBUG {
      (Stream proc )
      /print load
	  //PDFR_STREAM {
        (<)
        /print load
	  } if
	} if
    1 dict dup /i -1 put
    /dup load
	/i 
	/get load
	1
	/add load
	/dup load
	3 
	1 
	/roll load
	/i
	/exch load
	/put load
	//knownget
	/exec load 
	/not load
	{ () }
	/if load
	//PDFR_DEBUG {
	  //PDFR_STREAM {
        /dup load
        /print load
	    (>)
	    /print load
	  } if
	  ( end of stream proc.\n)
	  /print load
	} if
  ] cvx
  //PDFR_DEBUG {
	(Stream reader ) print dup ==
  } if
  0 () /SubFileDecode filter
} bind def

/RunDelayedStream % <stream_obj> RunStream -
{
  //MakeStreamReader exec 								% file
  mark exch
  cvx exec													%
  counttomark 0 ne {
    mark (Data left on ostack after a delayed stream execution.) //error exec
  } if
  cleartomark
} bind def

% ===================== Font Management ======================

/InstalledFonts 50 dict def

/GetInstalledFont % <name> GetInstalledFont <font>
{ currentglobal exch true setglobal								% g n
  dup //InstalledFonts exch knownget {						    % g n f
    exch pop													% g f
  } {															% g n
    dup findfont dup 3 1 roll									% g f n f
	//InstalledFonts 3 1 roll put								% g f
  } ifelse
  exch setglobal
} bind def

/RemoveFontNamePrefix % <name> RemoveFontNamePrefix <name>
{ =string cvs true
  0 1 5 {
    2 index exch get //IsUpper exec not {
	   pop false exit
	} if
  } for
  { (+) search {
      pop pop
    } if
  } if
  cvn
} bind def

/CheckFont % <key> <val> CheckFont <key> <val>
{ dup /Type get /Font ne {
    mark (Resource ) 3 index ( must have /Type/Font .) //error exec
  } if
} bind def

/CheckEncoding %  <key> <val> CheckEncoding <key> <val>
{ dup type /nametype ne {
    dup /Type get /Encoding ne {
      mark (Resource ) 3 index ( must have /Type/Encoding .) //error exec
    } if
  } if
} bind def

/ObtainEncoding % <font_resource> ObtainEncoding <font_resource>
{ dup /Encoding known {
    dup dup /Encoding //CheckEncoding //ResolveD exec			% fr fr er|e|n
    dup type dup /arraytype eq exch /packedarraytype eq or {
      % Already resolved.
	  pop pop
    } {
      dup type /nametype eq {
        /Encoding findresource									% fr fr e
      } {
        dup /BaseEncoding //knownget exec not {
	      /StandardEncoding
	    } if
	    /Encoding findresource									% fr fr er e
	    exch													% fr fr e er
	    /Differences //knownget exec {							% fr fr e d
	      exch dup length array copy exch
	      0 exch												% fr fr e 0 d
	      {														% fr fr e i v
	        dup type /integertype eq {
		      exch pop
	        } {
		      3 copy put pop									% fr fr e i
		      1 add
	        } ifelse
	      } forall
	      pop													% fr fr e
	    } if													% fr fr e
      } ifelse													% fr fr e
      /Encoding exch put										% fr
    } ifelse
  } {
	dup /Encoding /StandardEncoding /Encoding findresource put
  } ifelse
} bind def

/ObtainMetrics % <font_resource> ObtainMetrics <font_resource>
{ dup /Widths //knownget exec {									% fr W
    1 index /Encoding get										% fr W E
	256 dict													% fr W E M
	3 index /Subtype get /TrueType eq {
	  1000
	} {
	  1
	} ifelse													% fr W E M s
	4 index /MissingWidth //knownget exec not {
	  0
	} if														% fr W E M s mw
	5 index /FirstChar //knownget exec not {
	  0
	} if														% fr W E M s mw c0
	6 5 roll													% fr E M s mw c0 W
	dup 0 exch 1 exch length 1 sub {							% fr E M s mw c0 W i
	  2 copy get												% fr E M s mw c0 W i w
	  exch 3 index add											% fr E M s mw c0 W w c
	  7 index exch get											% fr E M s mw c0 W w n
	  dup null ne {
	    6 index 3 1 roll exch									% fr E M s mw c0 W M n w
	    dup 0 eq {
	      pop 5 index
	    } if
	    6 index div						
	    put														% fr E M s mw c0 W
	  } {
	    pop pop
	  } ifelse
	} for
	pop pop pop pop exch pop									% fr M
	1 index exch /Metrics put									% fr
  } {
	dup /MissingWidth //knownget exec {							% fr mw
	  256 dict													% fr mw M
	  2 index /Encoding get {									% fr mw M e
	    dup null ne {
		  3 copy 3 2 roll put									% fr mw M e
		} if
		pop														% fr mw M
	  } forall
	  exch pop													% fr M
	  1 index exch /Metrics put									% fr
	} if
  } ifelse
} bind def

/NotDef	% - NotDef -
{ % A Type 3 font is on dstack.
  FontMatrix aload pop pop pop exch pop exch pop                % sx sy
  1 exch div exch
  1 exch div exch												% wx wy
  1 index 0 setcharwidth
  o setlinewidth
  0 0 moveto
  2 copy rlineto
  1 index 0 rlineto
  neg exch neg exch rlineto										%
  closepath stroke
} bind def

/BuildChar  % <font> <char_code> BuildChar -
{ //PDFR_DEBUG {
    (BuildChar ) print dup //=only exec ( ) print
  } if
  exch begin
    Encoding exch get				                            % n
	//PDFR_DEBUG {
	  dup =
	} if
	dup null eq {
	  pop //NotDef exec											%
	} {															% n
	  CharProcs exch //knownget exec {							% cp_stream
	    //RunDelayedStream exec
	  } {
	    //NotDef exec
	  } ifelse
	} ifelse													%
  end % font
} bind def

/ResolveAndSetFont  % <resource_name> <size> ResolveAndSetFont -
{ exch dup															% s rn rn
  //PDFReader /CurrentObject get /Context get /Resources get 
  /Font //DoNothing //ResolveD exec
  exch //CheckFont //ResolveD exec									% s rn fr
  dup /Font //knownget exec {										% s rn fr f
    exch pop exch pop
  } {
    //ObtainEncoding exec
    //ObtainMetrics exec
    dup /Subtype get /Type3 eq {									% s rn fr
	  2 copy exch /FontName exch put
	  dup /CharProcs get //ResolveDict exec
	  dup /FontType 3 put
	  dup /BuildChar //BuildChar put
	  dup dup /Font exch put
	  % Ignore Metrics because pdfwrite duplicates it 
	  % from setcharwidth/setcachedevice.
	  dup 3 1 roll													% s fr rn fr
	  definefont													% s fr f
	  2 copy ne { 
	    % The interpreter copied the font dictionary while 'definefont'
		% Need to update the font pointer in the resource.
		2 copy /Font exch put										% s fr f
	  } if
	  exch pop														% s f
    } {																% s rn fr
      (Underimplemented SetFont)=
	  exch pop														% s fr
      dup /BaseFont get												% s fr n
	  //RemoveFontNamePrefix exec									% s fr n
	  //PDFR_DEBUG {
	    (Font ) print dup =
	  } if															% s fr n
	  //GetInstalledFont exec										% s fr f
	  dup length dict copy											% s fr f
	  dup 2 index /Encoding get										% s fr f f e
	  /Encoding exch put											% s fr f
	  1 index /Metrics //knownget exec {							% s fr f M
	    1 index exch /Metrics exch put								% s fr f
	  } if
	  % todo: set Metrics here
	  1 index /BaseFont get											% s fr f n
	  exch definefont												% s fr f
	  dup 3 1 roll													% s f fr f
	  /Font exch put												% s f
	} ifelse
  } ifelse
  exch scalefont setfont
} bind def

% ===================== Color Spaces and Colors ==============

/CheckColorSpace %  <key> <val> CheckColorSpace  <key> <val>
{
  dup type /arraytype ne {
    mark (Resource ) 3 index ( must be an array.) //error exec
  } if
} bind def

/SubstitutePDFColorSpace % <array> SubstitutePDFColorSpace <array>
{ { 
    dup 0 get /Pattern eq {
	  exit
	} if
	dup 0 get /Indexed eq {
	  exit
	} if
	dup 0 get /Separation eq {
	  exit
	} if
	dup 0 get /CalGray eq {
	  1 get													% n dict
	  dup /Gamma //knownget exec {
	    [ exch /exp load ] cvx
	    1 index exch /DecodeLMN exch put
	  } if				
	  [ exch /CIEBasedA exch ]							    % n []
	  exit
	} if
	dup 0 get /CalRGB eq {
	  1 get													% n dict
	  dup /Matrix //knownget exec { 
	    1 index exch /MatrixLMN exch put
	  } if
	  dup /Gamma //knownget exec {
	    aload pop
	    [ exch /exp load ] cvx
	    3 1 roll
	    [ exch /exp load ] cvx
	    3 1 roll
	    [ exch /exp load ] cvx
	    3 1 roll
	    3 array astore
	    1 index exch /DecodeLMN exch put
	  } if				
	  [ exch /CIEBasedABC exch ]							% n []
	  exit
	} if
    mark exch (Unimplemented color space ) exch //error exec
  } loop
} bind def

/ResolveColorSpaceArray  % <color_space> ResolveColorSpaceArray <color_space>
{
  dup 0 get /Indexed eq {
    % The first element mat be a reference.
    dup 1 get dup xcheck {
	  exec
	  1 index exch 1 exch put
	} {
	  pop	  
	} ifelse
	dup 1 get dup type /arraytype eq {
	  //SubstitutePDFColorSpace exec
	  1 index exch 1 exch put
	} {
	  pop
	} ifelse
  } if
} bind def

/ResolveColorSpace  % <name> ResolveColorSpace <color_space>
{ 
  dup //PDFColorSpaces exch //knownget exec {
    exch pop
  } {
    dup															% n n
    //PDFReader /CurrentObject get /Context get /Resources get 
    /ColorSpace //DoNothing //ResolveD exec
    exch //CheckColorSpace //ResolveD exec						% n cs
	dup type /arraytype eq {
	  //SubstitutePDFColorSpace exec
	  dup //PDFColorSpaces 4 2 roll put						    % []
	} if
  } ifelse
} bind def

/CheckPattern %  <key> <val> CheckPattern  <key> <val>
{
  dup /Type get /Pattern ne {
    mark (Resource ) 3 index ( must have /Type/Pattern .) //error exec
  } if
} bind def

/PaintProc % 
{ /Context get									% pattern_object
  //RunDelayedStream exec
} bind def

/ResolvePattern % <name> ResolvePattern <pattern>
{
  dup												% n n
  % Since makepattern makes a local dictionary,
  % we cahche them in userdict, which is in local VM.
  % Assuming unique resource name through the document
  userdict /PDFR_Patterns get						% n n d
  exch //knownget exec {							% n p
    exch pop										% p
  } {												% n
    dup												% n n
    //PDFReader /CurrentObject get /Context get /Resources get 
    /Pattern //DoNothing //ResolveD exec
    exch //CheckPattern //ResolveD exec				% n o
    dup dup /Context exch put
	dup /Resources //DoNothing //ResolveD exec pop
	dup /PaintProc //PaintProc put
	dup /Matrix get
	gsave userdict /PDFR_InitialGS get setgstate
	makepattern										% n p
	grestore
	dup userdict /PDFR_Patterns get					% n p p d
	4 2 roll										% p d n p
	put												% p
  } ifelse
} bind def

/SetColor % Same arguments and result as for scn
{ currentcolorspace dup type /nametype eq {
    pop setcolor    
  } {
    0 get /Pattern eq {
	  ResolvePattern setpattern
	} {
	  setcolor
	} ifelse
  } ifelse
} bind def

% ===================== Images ===============================

/ImageKeys 15 dict begin
  /BPC /BitsPerComponent def
  /CS /ColorSpace def
  /D /Decode def
  /DP /DecodeParams def
  /F /Filter def
  /H /Height def
  /IM /ImageMask def
  % /Intent is undefined - pdfwrite must take care of.
  /I /Interpolate def
  /W /Width def
currentdict end def

/ImageValues 15 dict begin
  /G   /DeviceGray def
  /RGB /DeviceRGB def
  /CMYK /DeviceCMYK def 
  /I   /Indexed def
  /AHx /ASCIIHexDecode def
  /A85 /ASCII85Decode def
  /LZW /LZWDecode def
  /Fl  /FlateDecode def
  /RL  /RunLengthDecode def
  /CCF /CCITTFaxDecode def
  /DCT /DCTDecode def
currentdict end def

/DecodeArrays 15 dict begin
  /DeviceGray { [0 1] } def
  /DeviceRGB { [0 1 0 1 0 1] } def
  /DeviceCMYK { [0 1 0 1 0 1 0 1] } def 
  /Indexed { dup /ColorSpace get 2 get [ exch 0 exch ] } def
  /Separation { [0 1] } def
  /CIEBasedA { [0 1] } def
  /CIEBasedABC { [0 1 0 1 0 1] } def
currentdict end def

/Substitute % <key> <dict> Substitute <key>
{ 1 index //knownget exec {
    exch pop
  } if
} bind def

/DebugImagePrinting  % <image_dict> DebugImagePrinting <image_dict>
{
  //PDFR_DEBUG {
    (Image :) =
    dup { exch //=only exec ( ) print == 
	} forall
  } if
} bind def

/CompleteImage  % <dict> CompleteInlineImage <image_dict>
{
  dup /Decode known not {
    dup /ColorSpace //knownget exec { 
	  dup type /arraytype eq {
	    0 get
	  } if
	  //DecodeArrays exch get exec 
	} {
	  [0 1]
	} ifelse
	1 index exch /Decode exch put
  } if
  dup /ImageMatrix [2 index /Width get 0 0 5 index /Height get neg 
					0 7 index /Height get] put % Not sure why upside down ?
  //DebugImagePrinting exec
} bind def

/CompleteInlineImage  % <dict> CompleteInlineImage <image_dict>
{
  dup /ImageType known not {
	dup /ImageType 1 put
  } if
  dup length dict exch {					% d key val
      exch //ImageKeys //Substitute exec
	dup /Filter eq {
	  exch //ImageValues //Substitute exec exch
	} if
	dup /ColorSpace eq {
	  exch 
	  dup //ImageValues exch //knownget exec {
	    exch pop
	  } {
	    //ResolveColorSpace exec
	  } ifelse
	  exch
	} if
	exch
	2 index 3 1 roll put
  } forall
  //CompleteImage exec
} bind def

/CompleteOutlineImage  % <dict> CompleteOutlineImage <image_dict>
{ 
  dup /ImageType known not {
	dup /ImageType 1 put
	dup /ColorSpace known {
	  dup /ColorSpace //CheckColorSpace //ResolveD exec
	  dup type /arraytype eq {
	    //ResolveColorSpaceArray exec
	    1 index exch /ColorSpace exch put
	  } {
	    pop
	  } ifelse
	} if
    //CompleteImage exec
  } if
  dup dup //MakeStreamReader exec /DataSource exch put
  % todo: ResetStreamReader if DataSource already exists.
} bind def

/DoImage % <image_dict> DoImage -
{
  gsave
  dup /ColorSpace //knownget exec { setcolorspace } if
  dup /ImageMask //knownget exec not { false } if
  { imagemask } { image } ifelse 
  grestore
} bind def

% ===================== Viewer State ===============

/GSave % - GSave -
{
  gsave
  //PDFReader /GraphicStateStackPointer get
  dup //GraphicStateStack exch get null eq {
	dup //GraphicStateStack exch //InitialGraphicState length dict put 
  } if
  dup //GraphicStateStack exch get
  //GraphicState exch copy pop
  1 add //PDFReader exch /GraphicStateStackPointer exch put
} bind def

/GRestore % - GRestore -
{
  grestore
  //PDFReader /GraphicStateStackPointer get
  1 sub dup
  //PDFReader exch /GraphicStateStackPointer exch put
  //GraphicStateStack exch get
  //GraphicState copy pop
} bind def


% ===================== Interpret Data Streams ===============

/SetFont  % <resource_name> <size> SetFont -
{ dup //GraphicState exch /FontSize exch put
  //ResolveAndSetFont exec
} bind def

/ShowText  % <string> ShowText -
{ //GraphicState /TextRenderingMode get 0 eq {
    //GraphicState /CharacterSpacing get 0
    32
    //GraphicState /WordSpacing get 0
    6 5 roll awidthshow
  } {
    //GraphicState /CharacterSpacing get 0 eq
    //GraphicState /WordSpacing get 0 eq and {
	  true charpath
	} {
      % Emulate with "{ charpath } cshow".
	  % Not sure how it works with CID fonts.
	  {														% c wx wy
	    currentpoint 5 4 roll								% wx wy x y c
	    ( ) dup 0 3 index put true charpath				    % wx wy x y c
	    5 1 roll											% c wx wy x y
	    moveto rmoveto										% c
	    //GraphicState /CharacterSpacing get 0 rmoveto		% c
	    32 eq {												%
		  //GraphicState /WordSpacing get 0 rmoveto
	    } if
	  }
      exch cshow
	} ifelse
  } ifelse
} bind def

/ShowTextBeg  % - ShowTextBeg -
{ //GraphicState /TextRenderingMode get 0 ne {
	currentpoint newpath moveto
  } if
} bind def

/ShowTextEnd  % - ShowTextEnd -
{ //GraphicState /TextRenderingMode get
  { dup 1 eq {
      stroke exit
    } if
    dup 2 eq {
      gsave fill grestore stroke exit
    } if
    dup 3 eq {
      currentpoint newpath moveto
    } if
    dup 4 eq {
      gsave fill grestore clip exit
    } if
    dup 5 eq {
      gsave stroke grestore clip exit
    } if
    dup 6 eq {
      gsave fill grestore gsave stroke grestore fill exit
    } if
    dup 7 eq {
      clip exit
    } if
    exit
  } loop
  pop
} bind def

/ShowTextWithGlyphPositioning % <array> ShowTextWithGlyphPositioning -
{ //ShowTextBeg exec
  { dup type /stringtype eq {
      //ShowText exec
    } {
	  neg 1000 div //GraphicState /FontSize get mul 0 rmoveto
	} ifelse
  } forall
  //ShowTextEnd exec
} bind def

/CheckFont % key val CheckFont key val
{ dup /Type get /ExtGState ne {
    mark (Resource ) 3 index ( must have /Type/ExtGState.) //error exec
  } if
} bind def

/SetTransfer % <operand> SetTransfer -
{
  dup /Identity eq {
    pop {} settransfer
  } {
    dup type /arraytype eq {
	  0 4 getinterval aload pop 
	  FunctionToProc11 4 1 roll
	  FunctionToProc11 4 1 roll
	  FunctionToProc11 4 1 roll
	  FunctionToProc11 4 1 roll
	  setcolortransfer
	} {
	  FunctionToProc11
	  settransfer
	} ifelse
  } iflese
} bind def

/CheckExtGState % <id> <obj> CheckExtGState <id> <obj>
{ dup /Type get /ExtGState ne {
    mark (Resource ) 3 index ( must have /Type/ExtGState.) //error exec
  } if
} bind def

/CheckHalftone % <id> <obj> CheckHalftone <id> <obj>
{ dup /HalftoneType known not {
    mark (Resource ) 3 index ( must have /HalftoneType.) //error exec
  } if
} bind def

/SetExtGState % <name> SetExtGState -
{
  //PDFReader /CurrentObject get /Context get /Resources get 
  /ExtGState //DoNothing //ResolveD exec
  exch //CheckExtGState //ResolveD exec							% s gs
  dup /LW //knownget exec {
    setlinewidth
  } if
  dup /LC //knownget exec {
    setlinecap
  } if
  dup /LJ //knownget exec {
    setlinejoin
  } if
  dup /ML //knownget exec {
    setmeterlimit
  } if
  dup /D //knownget exec {
    setdash
  } if
  dup /RI //knownget exec {
    % Ghostscript never writes it.
    mark (Unimplemented ExtGState.RI) //error exec
  } if
  dup /OP //knownget exec {
    % pdfwrite must take care of stroking/filling
    setoverprint
  } if
  dup /op //knownget exec {
    setoverprint
  } if
  dup /OPM //knownget exec {
    % pdfwrite must take care of.
    mark (Unimplemented ExtGState.OPM) //error exec
  } if
  dup /Font //knownget exec {
    % Ghostscript never writes it.
    mark (Unimplemented ExtGState.Font) //error exec
  } if
  dup /BG //knownget exec {
    setblackgeneration
  } if
  dup /BG2 //knownget exec {
    dup /Default eq {
	  //InitialExtGState /BG2 get
	} if
	setblackgeneration
  } if
  dup /UCR //knownget exec {
	setundercolorremoval
  } if
  dup /UCR2 //knownget exec {
    dup /Default eq {
	  //InitialExtGState /UCR2 get
	} if
	setundercolorremoval
  } if
  dup /TR //knownget exec {
	//SetTransfer exec
  } if
  dup /TR2 //knownget exec {
	dup /Default eq {
	  pop //InitialExtGState /TR2 get
	  aload pop setcolortransfer
	} {
	  //SetTransfer exec
	} ifelse
  } if
  dup /HT //knownget exec {
	dup /Default eq {
	  pop //InitialExtGState /HT get
	  sethalftone
	} {
	  pop dup /HT //CheckHalftone //ResolveD exec
	  sethalftone
	} ifelase
  } if
  dup /FL //knownget exec {
	setflattness
  } if
  dup /SM //knownget exec {
	setsmoothness
  } if
  dup /SA //knownget exec {
	setstrokeadjust
  } if
  dup /BM //knownget exec {
    % pdfwrite must take care of.
    mark (Unimplemented ExtGState.BM) //error exec
  } if
  dup /SMask //knownget exec {
    % pdfwrite must take care of.
    mark (Unimplemented ExtGState.SMask) //error exec
  } if
  dup /CA //knownget exec {
    % pdfwrite must take care of.
    mark (Unimplemented ExtGState.CA) //error exec
  } if
  dup /ca //knownget exec {
    % pdfwrite must take care of.
    mark (Unimplemented ExtGState.ca) //error exec
  } if
  dup /AIS //knownget exec {
    % pdfwrite must take care of.
    mark (Unimplemented ExtGState.AIS) //error exec
  } if
  dup /TK //knownget exec {
    % pdfwrite must take care of.
    mark (Unimplemented ExtGState.TK) //error exec
  } if
  pop
} bind def

/CheckXObject  % <id> <obj> CheckHalftone <id> <obj>
{ dup /Subtype get dup /Image ne exch dup /Form ne exch /PS ne and and {
    mark (Resource ) 3 index ( must have /Subtype /Image or /Form or /PS.) //error exec
  } if
} bind def

/DoXObject % <name> DoXObject -
{
  //PDFReader /CurrentObject get /Context get /Resources get 
  /XObject //DoNothing //ResolveD exec
  exch //CheckXObject //ResolveD exec
  dup /Subtype get
  dup /Image eq {
    pop
    //CompleteOutlineImage exec
	//DoImage exec
  } {
    mark exch (unimplemented XObject type ) exch //error exec
  } ifelse
} bind def

/Operators 50 dict begin
  /q { //GSave exec } bind def
  /Q { //GRestore exec } bind def
  /cm { //TempMatrix astore concat } bind def
  /i { 1 .min setflat } bind def
  /J /setlinecap load def
  /d /setdash load def
  /j /setlinejoin load def
  /w /setlinewidth load def
  /M /setmiterlimit load def
  /gs { SetExtGState } bind def

  /g /setgray load def
  /rg /setrgbcolor load def
  /k /setcmykcolor load def
  /cs { ResolveColorSpace setcolorspace } bind def
  /sc /setcolor load def
  /scn { //SetColor exec } bind def
  /G /setgray load def
  /RG /setrgbcolor load def
  /K /setcmykcolor load def
  /CS { ResolveColorSpace setcolorspace } bind def
  /ri { SetColorRenderingIntent } bind def
  /SC /setcolor load def
  /SCN { //SetColor exec } bind def

  /m /moveto load def
  /l /lineto load def
  /c /curveto load def
  /v { currentpoint 6 2 roll curveto } bind def
  /y { 2 copy curveto } bind def
  /re {
    4 2 roll moveto  exch dup 0 rlineto  0 3 -1 roll rlineto  neg 0 rlineto
    closepath
  } def
  /h /closepath load def
  /n /newpath load def
  /S /stroke load def
  /s { closepath stroke } bind def
  /f /fill load def
  /f* /eofill load def
  /B { gsave fill grestore stroke } bind def
  /b { closepath gsave fill grestore stroke } bind def
  /B* { gsave eofill grestore stroke } bind def
  /b* { closepath gsave eofill grestore stroke } bind def
  /W /clip load def
  /W* /eoclip load def
  /sh { ResolveShading shfill } bind def

  /Do { //DoXObject exec } bind def

  /BI { currentglobal false setglobal << } bind def
  /ID { >>
		dup /DataSource currentfile put
        //CompleteInlineImage exec
		exch setglobal
		//DoImage exec
	  } bind def
  /EI {} bind def

  /BT { gsave //GraphicState /InitialTextMatrix get currentmatrix pop } bind def
  /ET { grestore } bind def
  /Tc { //GraphicState exch /CharacterSpacing exch put } bind def
  /TL { //GraphicState exch /TextLeading exch put } bind def
  /Tr { //GraphicState exch /TextRenderingMode exch put } bind def
  /Ts {  % Ghostscript never generates it.
	    mark (Unimplemented SetTextRise) //error exec
	  } bind def
  /Tw { //GraphicState exch /WordSpacing exch put } bind def
  /Tz { % Ghostscript never generates it.
	    mark (Unimplemented SetHorizontalTextScaling) //error exec
      } bind def
  /Td { translate 0 0 moveto } bind def
  /TD { dup neg //TL exec //Td exec } bind def
  /Tm { //GraphicState /InitialTextMatrix get setmatrix
        //TempMatrix astore concat
        0 0 moveto } bind def
  /T* { 0 //GraphicState /TextLeading get //Td exec } bind def
  /Tj { //ShowTextBeg exec  //ShowText exec  //ShowTextEnd exec } bind def
  /' { //T* exec //ShowText exec } bind def
  /" { 3 2 roll //Tw exec exch //Tc exec //' exec} bind def
  /TJ //ShowTextWithGlyphPositioning def
  /Tf //SetFont def

  /d0 /setcharwidth load def
  /d1 /setcachedevice load def

  /BDC { BeginMarkedContentSequenceWithPropertyList } bind def
  /BMC { BeginMarkedContentSequence } bind def
  /EMC { EndMarkedContentSequence } bind def
  /BX { BeginCompatibilitySection } bind def
  /EX { EndCompatibilitySection } bind def
  /DP { DefineMarkedContentPointWithPropertyList } bind def
  /MP { DefineMarkedContentPoint } bind def
currentdict end def

//PDFR_STREAM {
  % Rebind operators with a debug tracing.
  //Operators length dict begin
  //Operators {												% n p
	exch dup												% p n n
	[ exch //=only /exec load								% p n [ n =only exec
	  ( ) /print load										% p n [ n =only exec () print
      8 7 roll												% n [ n =only exec () print p
	  dup type /arraytype eq {
	    /exec load											% n [ n =only exec () print p exec
	  } if
	  ( ) /print load
	] cvx													% n {}
	def
  } forall
  currentdict end /Operators exch def
} if

% Leaving the procset on the dictionary stack to provide 
% definitions of obj, endobj, stream, endstream, R, xref.
%%EndPrologue
