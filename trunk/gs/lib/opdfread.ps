%!PS-Adobe-2.0
%
%	 Copyright (C) 2002 artofcode LLC.	All rights reserved.
% 
% This software is provided AS-IS with no warranty, either express or
% implied.
% 
% This software is distributed under license and may not be copied,
% modified or distributed except as expressly authorized under the terms
% of the license contained in the file LICENSE in this distribution.
% 
% For more information about licensing, please refer to
% http://www.ghostscript.com/licensing/. For information on
% commercial licensing, go to http://www.artifex.com/licensing/ or
% contact Artifex Software, Inc., 101 Lucas Valley Road #110,
% San Rafael, CA  94903, U.S.A., +1(415)492-9861.

% $Id$
% pdfread.ps - A procset for interpreting an ordered PDF 1.3 file.

% This module defines routines for interpreting a PDF file with
% a Postscript interpreter. To convert a PDF file into Postscript 
% just pre-contcatenate this file. The PDF file must satisfy 
% few constraints :
%
% 1. It must contain only Postscript level 2 objects encoded with
% the PDF 1.3 language. Higher PDF levels must be re-distilled
% with CompatibilityLevel=1.3 .
%
% 2. Objects must be ordered so that any resource be defined before
% its usage.
%
% 3. The PDF file must not include other PDF files.
% Consequently we have a single instance of the PDF reader.
% We use this fact to simplify binding of the routines.
% 
% 4. The PDF root object must always have the object id 1.
% 
% 5. Generations besides 0 are not allowed.
%
% 6. xref must appear after all objects.
%
% Assuming the currentfile isn't positionable.
% As a consequence, the reader fully ignores xref.


% !!!!!!!!!!!!!  THIS REVISION IS INCOMPLETE !!!!!!!!!!!!!!!!!!!!
% It only reads a PDF, but it does not do any attempt to interprete it.


true setglobal
30 dict begin

% ===================== Debugging =========================================

/DefaultSwitch	% <name> DefaultSwitch -
{
  dup where {
    pop pop
  } {
    false def
  } ifelse
} bind def

/=string 256 string def

/=only {
  //=string cvs print
} bind def

/PDFR_DEBUG DefaultSwitch
/PDFR_DUMP DefaultSwitch
/PDFR_STREAM DefaultSwitch

/error	%  mark <object> .... error -
{ % A stub for a while.
  counttomark 1 sub -1 0 {
    index dup type /arraytype eq { == } { =only } ifelse
  } for
  () =
  cleartomark
  % Assuming ....Undefined is never defined. 
  % Use it to emit an error.
  ....Undefined
} bind def

% ===================== Utilities =========================================

/knownget % <dict> <key> knownget <value> true
	  % <dict> <key> knownget false
{
  2 copy known {
    get true
  } {
    pop pop false
  } ifelse
} bind def

/IsUpper  % <int> IsUpper <bool>
{ dup (A) 0 get ge exch (Z) 0 get le and
} bind def

% ===================== Work Data =========================================

/BlockBuffer 4096 string def
/PDFReader currentdict def
/ObjectRegistry 50 array def % may grow later
/CurrentObject null def
/DoneDocumentStructure false def
/GraphicState 20 dict begin
  /InitialTextMatrix matrix def
currentdict end def
/TempMatrix matrix def
/GraphicStateStack 20 array def
/GraphicStateStackPointer 0 def
/PDFColorSpaces 50 dict def
/FuncDataReader 10 dict def

% Debug data :
/StreamDumperBuffer //PDFR_DEBUG { 1024 } { 1 } ifelse string def

% We need some structures in local VM, put then into the userdict :
currentglobal false setglobal
userdict /PDFR_InitialGS gstate put
userdict /PDFR_Patterns 50 dict put
setglobal

% ===================== Constants =========================================

/InitialExtGState 20 dict begin
  /BG2 currentblackgeneration def
  /UCR2 currentundercolorremoval def
  /TR2 [ currentcolortransfer ] def
  /HT currenthalftone def
currentdict end readonly def

/InitialGraphicState 20 dict begin
  /FontSize 0 def
  /CharacterSpacing 0 def
  /TextLeading 0 def
  /TextRenderingMode 0 def
  /WordSpacing 0 def
currentdict end readonly def

/SimpleColorSpaceNames 15 dict begin
  /DeviceGray true def
  /DeviceRGB true def
  /DeviceCMYK true def 
currentdict end readonly def

/1_24_bitshift_1_sub 1 24 bitshift 1 sub def

% ===================== Reading PDF objects ===============================

/Register % <DefaultDaemon> <id> <obj> Register -
{
  exch dup						% d obj id id
  //PDFReader /ObjectRegistry get length ge {
    dup dup 2 idiv add array dup			% d obj id [n] [n]
    //PDFReader /ObjectRegistry get dup length		% d obj id [n] [n] [o] l
    3 2 roll exch					% d obj id [n] [o] [n] l
    0 exch getinterval copy pop 			% d obj id [n]
    //PDFReader exch /ObjectRegistry exch put		% d obj id
  } if
  exch //PDFReader /ObjectRegistry get			% d id obj r
  3 1 roll						% d r id obj
  3 copy pop get					% d r id obj e
  dup xcheck {						% d r id obj e
    5 4 roll pop					% r id obj e
    % We've got a definition daemon, execute it :
    exec
  } {							% d r id obj e
    dup null ne {					% d r id obj e
      mark (The object ) 4 index ( already defined : ) 4 index //error exec
    } {
      pop
    } ifelse
    4 3 roll						% r id obj d
    % Execute the default daemon :
    exec
  } ifelse						% r id obj
  put							%
} bind def

/GetRegistered % <id> GetRegistered <obj>
{
  //PDFReader /ObjectRegistry get			% id r
  dup length						% id r l
  2 index le {						% id r
    exch mark exch (Object ) exch ( isn't defined before needed (1).) //error exec 
  } if
  1 index get						% id e
  dup xcheck {
    exch mark exch (Object ) exch ( isn't defined before needed (2).) //error exec 
  } { 
    dup null eq {
      exch mark exch (Object ) exch ( isn't defined before needed (3).) //error exec 
    } if
    exch pop						% e
  } ifelse

} bind def

/PrintReference % <array> PrintReference <array>
{
  //PDFR_DEBUG {
    ({ ) print
    dup {
      =only ( ) print
    } forall
    ( }) =
  } if
} bind def

/R % <id> <gen> R <daemon>
{ % Make a reference daemon.
  0 ne {
    exch mark exch (A referred object generation ) exch ( isn't 0.) //error exec
  } if							% id
  [ % <id> proc <obj>
    exch //GetRegistered /exec load 
  ] cvx
  //PrintReference exec
} bind def

/DoNothing 
{
} def

/RunTypeDaemon	% <id> <obj> RunTypeDaemon <id> <obj>
{
  dup type /dicttype eq {
    dup /Type //knownget exec {
      //PDFReader /TypeDaemons get exch
      //knownget exec {
	exec
      } if
    } if
  } if
} bind def

/obj % <id> <generation> obj <id>
{
  //PDFR_DEBUG {
    (Defining ) print 1 index =only ( ) print dup =only ( obj) =
  } if
  0 ne {
    exch mark exch (An object generation ) exch ( isn't 0.) //error exec
  } if
} bind def

/endobj  % <id> <obj> endobj -
{
  //PDFR_DEBUG {
    (Storing ) print 1 index =
  } if
  //RunTypeDaemon exec
  //DoNothing 3 1 roll //Register exec
} bind def

/StoreBlock % <buf> StoreBlock -
{ % Stores a (encoded) stream data block to the current object.
  //PDFR_DEBUG {
    (StoreBlock ) print //PDFReader /BlockCount get =only (, Length = ) print dup length =
  } if
  dup length string copy
  //PDFReader /BlockCount get exch			% i s
  //PDFReader /CurrentObject get 3 1 roll		% o i s
  put							%
  //PDFReader /BlockCount get 1 add
  //PDFReader exch /BlockCount exch put
} bind def

/CheckLength % <val> CheckNumber <val>
{ dup type /integertype ne {
    mark (Object length isn't an integer.) //error exec
  } if
} bind def

/ResolveD % <dict> <key> <check> ResolveD <value>
{
  3 copy pop get					% <> key {} e
  dup xcheck {
    % We've got a reference daemon, execute it :
    //PDFR_DEBUG {
      (Resolving ) print //PrintReference exec
    } if
    exec						% <> key {} val
    exch exec						% <> key val
  } {
    exch pop
  } ifelse
  dup 4 1 roll						% val <> key val
  put							% val
} bind def

/ResolveA   % <array> <index> <check> ResolveA <value>
{ 2 index 2 index get
  dup xcheck {
    exec
    exch exec
    3 copy put
  } {
    exch pop
  } ifelse
  exch pop exch pop
} bind def

/StoreStream  % <id> <obj> StoreStream <id> <obj>
{ % Stores a (encoded) data stream copy to the current object.
  dup //PDFReader exch /CurrentObject exch put		% id obj
  //PDFReader /BlockCount 0 put
  dup /Length //CheckLength //ResolveD exec		% id obj l
  //PDFR_DEBUG {
    (StoreStream Length = ) print dup =
  } if
  currentfile exch () /SubFileDecode filter		% id obj file
  { dup //BlockBuffer readstring {			% id obj file buf
      //StoreBlock exec
    } {
      //StoreBlock exec
      exit
    } ifelse						% id obj file
  } loop
  pop							% id obj
  //PDFReader /CurrentObject null put
  //PDFR_DEBUG {
    (StoreStream end.) =
  } if
} bind def

/MakeStreamDumper % <file> MakeStreamDumper <file>
{ % Debug purpose only.
  currentglobal exch dup gcheck setglobal
  [ exch
    { //StreamDumperBuffer 
      readstring pop
      (StreamDumper <) print dup print (>\n) print
    } /exec load    
  ] cvx 0 () /SubFileDecode filter
  exch setglobal
} bind def

/AppendFilters  % <file> <dict> AppendFilters <file>
{
  dup 3 1 roll					    % d f
  /Filter //knownget exec {			    % d f n
    dup type /nametype eq {
      2 index /DecodeParms //knownget exec {
        exch
      } if
      filter
    } {
      dup 0 exch 1 exch length 1 sub {		    % d [] i
        2 index /DecodeParms //knownget exec {	    % d [] i DP
          1 index get				    % d [] i dp
        } if
	exch 2 index exch get			    % d [] dp fn
        filter
      } for
    } ifelse
    //PDFR_DEBUG {
      //MakeStreamDumper exec
    } if
  } if
  exch pop
} bind def

/ExecuteStream	% <id> <obj> ExecuteStream <id> <obj>
{ % Executes a (encoded) data stream.
  dup //PDFReader exch /CurrentObject exch put		% id obj
  dup /Length //CheckLength //ResolveD exec		% id obj l
  //PDFR_DEBUG {
    (ExecuteStream id = ) print 2 index =only ( Length = ) print dup =
  } if
  //PDFReader /InitialGraphicState get 
  //PDFReader /GraphicState get copy pop
  //PDFReader /Operators get begin
  currentfile exch () /SubFileDecode filter		% id obj file
  1 index //AppendFilters exec
  cvx mark exch 					% id obj mark file
  exec
  counttomark 0 ne {
    mark (Data left on ostack after an immediate stream execution.) //error exec
  } if
  cleartomark						% id obj
  end % Operators
  //PDFR_DEBUG {
    (ExecuteStream end.) =
  } if
  //PDFReader /CurrentObject null put
  showpage
} bind def

/stream  % <id> <obj> stream <id> <obj>
{ 
  //PDFR_DEBUG {
    1 index =only ( stream) =
  } if							% id obj
  % Run the object definition daemon, if exists :
  //PDFReader /ObjectRegistry get dup length 3 index	% id obj r l id
  gt {							% id obj r
    2 index get 
    dup xcheck {
      exec
      % Disable the daemon :
      //PDFReader /ObjectRegistry get 2 index null put
    } {
      pop
    } ifelse
  } {
    pop
  } ifelse						% id obj
  dup /ImmediateExec known {
    //ExecuteStream exec
  } {
    //StoreStream exec
  } ifelse
} bind def

/endstream % <id> <obj> endstream <id> <obj>
{ % Nothing to do.
} bind def

/xref % - xref -
{ 
  //PDFR_DEBUG {
    (xref) =
    //PDFR_DUMP {
      //PDFReader /ObjectRegistry get ==
    } if
  } if
  end % The procset
  count 0 ne {
    mark (Excessive data on estack at the end of the interpretation.) //error exec
  } if
  currentfile flushfile
} bind def

% ===================== Restoring the PDF Document Structure ===============

/ResolveDict  % <dict> /ResolveDict -
{ dup { 						% d key val
    pop 1 index exch					% d cp key
    //DoNothing //ResolveD exec 			% d obj
    pop 						% d
  } forall
  pop							%
} bind def

/PageContentsDaemon % <id> <obj> <node> PageContentsDaemon <id> <obj>
{ % Note: an excessive operand from a prebond procedure.
  //PDFR_DEBUG {
    (Executing PageContentsDaemon for ) print 2 index =
  } if							% id obj node
  1 index exch /Context exch put			% id obj
  dup /ImmediateExec true put
} bind def

/TypeDaemons <<  % <id> <obj> proc <id> <obj>
  /Page 
  { //PDFR_DEBUG {
      (Recognized a page.)=
    } if
    dup /Contents //knownget exec {
    0 get //DoNothing exch				% id obj dn id1
    [ % <id> <obj> proc <id> <obj>
      3 index //PageContentsDaemon /exec load
    ] cvx						% id obj {}
    //Register exec					% id obj
    } {
      (fixme: page with no Contents won't be printed.) =
    } ifelse
  } bind
>> def

/MakeStreamReader % <obj> MakeStreamReader <file>
{ dup
  [ 
    exch
    //PDFR_DEBUG {
      (Stream proc )
      /print load
      //PDFR_STREAM {
	(<)
	/print load
      } if
    } if
    1 dict dup /i -1 put
    /dup load
    /i 
    /get load
    1
    /add load
    /dup load
    3 
    1 
    /roll load
    /i
    /exch load
    /put load
    //knownget
    /exec load 
    /not load
    { () }
    /if load
    //PDFR_DEBUG {
      //PDFR_STREAM {
	/dup load
	/print load
	(>)
	/print load
      } if
      ( end of stream proc.\n)
      /print load
    } if
  ] cvx
  //PDFR_DEBUG {
    (Stream reader ) print dup ==
  } if
  0 () /SubFileDecode filter
  exch //AppendFilters exec
} bind def

/RunDelayedStream % <stream_obj> RunStream -
{
  //MakeStreamReader exec					% file
  mark exch
  cvx exec							%
  counttomark 0 ne {
    mark (Data left on ostack after a delayed stream execution.) //error exec
  } if
  cleartomark
} bind def

% ===================== Font Management ======================

/InstalledFonts 50 dict def

/GetInstalledFont % <name> GetInstalledFont <font>
{ currentglobal exch true setglobal				% g n
  dup //InstalledFonts exch knownget {				% g n f
    exch pop							% g f
  } {								% g n
    dup findfont dup 3 1 roll					% g f n f
    //InstalledFonts 3 1 roll put				% g f
  } ifelse
  exch setglobal
} bind def

/RemoveFontNamePrefix % <name> RemoveFontNamePrefix <name>
{ =string cvs true
  0 1 5 {
    2 index exch get //IsUpper exec not {
      pop false exit
    } if
  } for
  { (+) search {
      pop pop
    } if
  } if
  cvn
} bind def

/CheckFont % <key> <val> CheckFont <key> <val>
{ dup /Type get /Font ne {
    mark (Resource ) 3 index ( must have /Type/Font .) //error exec
  } if
} bind def

/CheckEncoding %  <key> <val> CheckEncoding <key> <val>
{ dup type /nametype ne {
    dup /Type get /Encoding ne {
      mark (Resource ) 3 index ( must have /Type/Encoding .) //error exec
    } if
  } if
} bind def

/ObtainEncoding % <font_resource> ObtainEncoding <font_resource>
{ dup /Encoding known {
    dup dup /Encoding //CheckEncoding //ResolveD exec	% fr fr er|e|n
    dup type dup /arraytype eq exch /packedarraytype eq or {
      % Already resolved.
      pop pop
    } {
      dup type /nametype eq {
	/Encoding findresource				% fr fr e
      } {
	dup /BaseEncoding //knownget exec not {
	  /StandardEncoding
	} if
	/Encoding findresource				% fr fr er e
	exch						% fr fr e er
	/Differences //knownget exec {			% fr fr e d
	  exch dup length array copy exch
	  0 exch					% fr fr e 0 d
	  {						% fr fr e i v
	    dup type /integertype eq {
	      exch pop
	    } {
	      3 copy put pop				% fr fr e i
	      1 add
	    } ifelse
	  } forall
	  pop						% fr fr e
	 } if						% fr fr e
      } ifelse						% fr fr e
      /Encoding exch put				% fr
    } ifelse
  } {
    dup /Encoding /StandardEncoding /Encoding findresource put
  } ifelse
} bind def

/ObtainMetrics % <font_resource> ObtainMetrics <font_resource>
{ dup /Widths //knownget exec { 			% fr W
    1 index /Encoding get				% fr W E
    256 dict						% fr W E M
    3 index /Subtype get /TrueType eq {
      1000
    } {
      1
    } ifelse						% fr W E M s
    4 index /MissingWidth //knownget exec not {
      0
    } if						% fr W E M s mw
    5 index /FirstChar //knownget exec not {
      0
    } if						% fr W E M s mw c0
    6 5 roll						% fr E M s mw c0 W
    dup 0 exch 1 exch length 1 sub {			% fr E M s mw c0 W i
      2 copy get					% fr E M s mw c0 W i w
      exch 3 index add					% fr E M s mw c0 W w c
      7 index exch get					% fr E M s mw c0 W w n
      dup null ne {
	6 index 3 1 roll exch				% fr E M s mw c0 W M n w
	dup 0 eq {
	  pop 5 index
	} if
	6 index div					
	put						% fr E M s mw c0 W
      } {
	pop pop
      } ifelse
    } for
    pop pop pop pop exch pop				% fr M
    1 index exch /Metrics put				% fr
  } {
    dup /MissingWidth //knownget exec { 		% fr mw
      256 dict						% fr mw M
      2 index /Encoding get {				% fr mw M e
	dup null ne {
	  3 copy 3 2 roll put				% fr mw M e
	} if
	pop						% fr mw M
      } forall
      exch pop						% fr M
      1 index exch /Metrics put 			% fr
    } if
  } ifelse
} bind def

/NotDef % - NotDef -
{ % A Type 3 font is on dstack.
  FontMatrix aload pop pop pop exch pop exch pop	% sx sy
  1 exch div exch
  1 exch div exch					% wx wy
  1 index 0 setcharwidth
  o setlinewidth
  0 0 moveto
  2 copy rlineto
  1 index 0 rlineto
  neg exch neg exch rlineto				%
  closepath stroke
} bind def

/BuildChar  % <font> <char_code> BuildChar -
{ //PDFR_DEBUG {
    (BuildChar ) print dup //=only exec ( ) print
  } if
  exch begin
  Encoding exch get					% n
  //PDFR_DEBUG {
    dup =
  } if
  dup null eq {
    pop //NotDef exec					%
  } {							% n
    CharProcs exch //knownget exec {			% cp_stream
      //RunDelayedStream exec
    } {
      //NotDef exec
    } ifelse
  } ifelse						%
  end % font
} bind def

/ResolveAndSetFont  % <resource_name> <size> ResolveAndSetFont -
{ exch dup						% s rn rn
  //PDFReader /CurrentObject get /Context get /Resources get 
  /Font //DoNothing //ResolveD exec
  exch //CheckFont //ResolveD exec			% s rn fr
  dup /Font //knownget exec {				% s rn fr f
    exch pop exch pop
  } {
    //ObtainEncoding exec
    //ObtainMetrics exec
    dup /Subtype get /Type3 eq {			% s rn fr
      2 copy exch /FontName exch put
      dup /CharProcs get //ResolveDict exec
      dup /FontType 3 put
      dup /BuildChar //BuildChar put
      dup dup /Font exch put
      % Ignore Metrics because pdfwrite duplicates it 
      % from setcharwidth/setcachedevice.
      dup 3 1 roll					% s fr rn fr
      definefont					% s fr f
      2 copy ne { 
	% The interpreter copied the font dictionary while 'definefont'
	% Need to update the font pointer in the resource.
	2 copy /Font exch put				% s fr f
      } if
      exch pop						% s f
    } { 						% s rn fr
      (Underimplemented SetFont)=
      exch pop						% s fr
      dup /BaseFont get 				% s fr n
      //RemoveFontNamePrefix exec			% s fr n
      //PDFR_DEBUG {
	(Font ) print dup =
      } if						% s fr n
      //GetInstalledFont exec				% s fr f
      dup length dict copy				% s fr f
      dup 2 index /Encoding get 			% s fr f f e
      /Encoding exch put				% s fr f
      1 index /Metrics //knownget exec {		% s fr f M
	1 index exch /Metrics exch put			% s fr f
      } if
      1 index /BaseFont get				% s fr f n
      exch definefont					% s fr f
      dup 3 1 roll					% s f fr f
      /Font exch put					% s f
    } ifelse
  } ifelse
  exch scalefont setfont
} bind def

% ===================== Functions ============================

/ScaleVal % <value> <Range> ScaleVal <scaled_value>
{
  aload pop						% v r0 r1
  1 index sub						% v r0 r1-r0
  3 2 roll mul add
} bind def

/ScaleArg % <arg> <Domain> ScaleArg <scaled_arg>
{
  aload pop						% a d0 d1
  1 index sub						% a d0 d1-d0
  3 1 roll						% d1-d0 a d0
  sub exch div						% (a-d0)/(d1-d0)
} bind def

/ScaleArgN % <arg0> ... <argN> <Domain> ScaleArg <scaled_arg0> ... <scaled_argN>
{
  dup length 2 idiv 1 sub -1 0 {			% a0 ... an [] i
    2 mul 2						% a0 ... an [] 2i 2
    2 index 3 1 roll getinterval			% a0 ... an [] []
    3 2 roll						% a0 ... [] [] an
    exch //ScaleArg exe 				% a0 ... [] an'
    1 index length 1 roll				% an' a0 ... []
  } for 						% a0' ... an'
} bind def


/ComputeFunction_10 % <scaled_arg> <sample_array> ComputeFunction_10 <result>
{ % Assuming a 1-argument 1-result function type 0.
  (ComputeFunction_10 beg ) print 1 index //=only exec ( stack=) print count =
  exch							% [] x
  dup 1 eq {
    pop dup length 1 sub get				% y
  } {
    1 index length 1 sub mul				% [] x*(l-1)
    dup dup floor sub					% [] x*(l-1) f
    dup 0 eq {
      pop cvi get					% y
    } {
      3 1 roll floor cvi				% f [] i
      2 getinterval					% f []
      aload pop 					% f y0 y1
      2 index mul 3 2 roll 1 exch sub 3 2 roll mul add	% y1*f+(1-f)*y0
    } ifelse
  } ifelse
  (ComputeFunction_10 end ) print dup //=only exec ( stack=) print count =
} bind def

/ComputeFunction_n0 % <arg0> .... <argn> <sample_array> ComputeFunction_n0 <result>
{ % Assuming a n-argument 1-result function type 0.
  mark (Unimplemented n-argument function type 0.) //error exec
} bind def

/FunctionToProc_x01 % <function_dict> <n> FunctionToProc_x01 <proc>
{ % Assuming a n-argument 1-result function type 0.
  % The stream is already converted to the array /Data.
  /Data get 0 get 
  [ exch 
    //PDFR_DEBUG {
      (Color space function beg, stack =) /print load /count load 1 /sub load //=only /exec load (\n) /print load
    } if
    //ComputeFunction_10 /exec load
    //PDFR_DEBUG {
      (Color space function end, stack =) /print load /count load //=only /exec load (\n) /print load
    } if
  ] cvx
  //PDFR_DEBUG {
    (Made a procedure for the 1-argument function :) =
    dup ==
  } if
} bind def

/FunctionProcDebugBeg  %  - FunctionProcDebugBeg -
{ (FunctionProcDebugBeg ) print count =
} bind def

/FunctionProcDebugEnd  %  - FunctionProcDebugEnd -
{ (FunctionProcDebugEnd ) print count =
} bind def

/FunctionToProc_x0n % <function_dict> <m> FunctionToProc_x0n <proc>
{ % Assuming a n-argument m-result function type 0.
  % The stream is already converted to the array /Data.
  %
  % Making the procedure : { Domain //ScaleArg exec ... n copy {} exec n+1 1 roll ... }
  % except "n copy" for the last chunk.
  %
  1 index /Size get length exch 			% f n m
  dup 7 mul 5 add array 				% f n m []
  PDFR_DEBUG {
    dup 0 //FunctionProcDebugBeg put
  } {
    dup 0 //DoNothing put
  } ifelse
  dup 1 /exec load put
  dup 2 5 index /Domain get put
  2 index 1 eq {
    dup 3 //ScaleArg put
  } {
    dup 3 //ScaleArgN put
  } ifelse
  dup 4 /exec load put
  1 index 1 sub 0 exch 1 exch { 			% f n m [] i
    dup 7 mul 5 add					% f n m [] i i1
    1 index 4 index 1 sub ne {
      dup 3 index exch 6 index put 1 add
      dup 3 index exch /copy load put 1 add
    } if
    [							% f n m [] i i1 [
      6 index /Data get 3 index get			% f n m [] i i1 [ di
      6 index 1 eq {
	//ComputeFunction_10 /exec load
      } {
	//ComputeFunction_n0 /exec load
      } ifelse
    ] cvx						% f n m [] i i1 {}
    3 index exch 2 index exch put 1 add 		% f n m [] i i1
    2 index 1 index /exec load put 1 add
    2 index 1 index 6 index 1 add put 1 add
    2 index 1 index 1 put 1 add
    2 index 1 index /roll load put			% f n m [] i i1
    pop pop						% f n m []
  } for
  PDFR_DEBUG {
    dup dup length 2 sub //FunctionProcDebugEnd put
  } {
    dup dup length 2 sub //DoNothing put
  } ifelse
  dup dup length 1 sub /exec load put
  cvx exch pop exch pop exch pop
  //PDFR_DEBUG {
    (Made a procedure for the n-argument function :) =
    dup ==
  } if
} bind def

/MakeTableRec % <func_obj> <n> MakeTableRec <array>
{
  0 % to be bound below
  exec
} bind def

/MakeTable % <func_obj> <n> MakeTable <array>
{ //PDFR_DEBUG {
    (MakeTable beg ) print count =
  } if
  1 index /Size get exch				% f S N
  1 sub dup						% f S n n
  3 1 roll						% f n S n
  get							% f n s
  array 						% f n []
  1 index 0 eq {
    exch pop exch pop					% []
  } {
    dup length - sub -1 0 {				% f n [] i
      3 index 3 index //MakeTableRec exec		% f n [] i []
      2 index 3 1 roll put				% f n []
    } for
    exch pop exch pop
  } ifelse
  //PDFR_DEBUG {
    (MakeTable end ) print count =
  } if
} bind def

//MakeTableRec 0 /MakeTable put

/StoreSample  % <value> <table> <dimensions> StoreSample -
{ % The reader in on the dictionary stack.
  1 sub 
  dup 0 eq {
    pop 						% v []
  } {
    -1 1 {						% v T i
      I exch get get					% v T[I[i]]
    } for						% v []
  } ifelse
  I 0 get 3 2 roll put
} bind def

/ReadSample32	% - ReadSample32 <value>
{
  4 {
    File read not {
      mark (Insufficient data for function.) //error exec
    } if
  } repeat
  pop % Ignore the last byte because it can't fit into 'real'.
  3 1 roll exch
  256 mul add 256 mul add
  //1_24_bitshift_1_sub div
} bind def

/ReadSample   % - ReadSample <value>
{ % The reader in on the dictionary stack.
  Buffer BitsLeft BitsPerSample
  { 2 copy ge {
      exit
    } if
    3 1 roll 
    8 add 3 1 roll
    256 mul File read not {
      mark (Insufficient data for function.) //error exec
    } if
    add
    3 1 roll
  } loop						% b bl pbs
  sub dup						% b bl-bps bl-bps
  2 index exch						% b bl-bps b bl-bps
  neg bitshift						% b bl-bps v
  2 copy exch bitshift					% b bl-bps v v<<(bl-bps)
  4 3 roll exch sub					% bl-bps v b-(v<<(bl-bps))
  /Buffer exch def					% bl-bps v
  exch /BitsLeft exch def				% v
  Div div						% v/(1<<pbs-1)
} bind def

/ReadSamplesRec % <dimensions> ReadSamplesRec -
{ 0 % Will be bound below
  exec
} bind def

/ReadSamples % <dimensions> ReadSamples -
{ % The reader in on the dictionary stack.
  (ReadSamples beg ) print count =
  dup 1 eq {
    pop
    0 1 Size 0 get 1 sub {
      I exch 0 exch put
      0 1 M 1 sub {
	dup Range exch 2 mul 2 getinterval		% m r 
	//PDFR_DEBUG {
	  (Will read a sample ... ) print
	} if
	BitsPerSample 32 eq { //ReadSample32 } { //ReadSample } ifelse
	exec exch //ScaleVal exec			% m v
	//PDFR_DEBUG {
	  (value=) print dup =
	} if
	exch Table exch get				% v []
	N //StoreSample exec				%
      } for
    } for
  } {
    1 sub 
    dup Size exch get 0 exch 1 exch 1 sub {		% d-1 i
      I exch 2 index exch put				% d-1
      //ReadSamplesRec exec
    } forall
  } ifelse
  (ReadSamples end ) print count =
} bind def

//ReadSamplesRec 0 //ReadSamples put

/StreamToArray % <obj> StreamToArray -
{ //PDFR_DEBUG {
    (StreamToArray beg ) print count =
  } if
  //FuncDataReader begin				% f
    dup /BitsPerSample get /BitsPerSample exch def
    dup /Size get length /N exch def
    dup /Range get length 2 idiv /M exch def
    1 BitsPerSample bitshift 1 sub /Div exch def
    /BitsLeft 0 def
    /Buffer 0 def
    dup /Size get /Size exch def			% f
    dup /Range get /Range exch def			% f
    /File 1 index //MakeStreamReader exec def		% f
    /I [ N { 0 } repeat ] def				% f
    M array						% f []
    dup length 1 sub -1 0 {				% f [] m
      2 index N //MakeTable exec			% f [] m T
      2 index 3 1 roll put				% f []
    } for
    /Table exch def					% f
    N //ReadSamples exec				% f
    PDFR_DEBUG {
      (Table = ) print Table ==
    } if
    /Data Table put					%
  end
  //PDFR_DEBUG {
    (StreamToArray end ) print count =
  } if
} bind def

/FunctionToProc10 % <function_dict> FunctionToProc10 <proc>
{ % Assuming a 1-argument function type 0.
  PDFR_DEBUG {
    (FunctionToProc10, Range = ) print dup /Range get ==
  } if
  dup /Order //knownget exec {
    1 ne {
      (Underimplemented function Type 0 Order 3.)=
    } if
  } if
  dup //StreamToArray exec				% f
  dup /Range get length dup 2 eq {
    pop //FunctionToProc_x01 exec			% proc
  } {
    2 idiv //FunctionToProc_x0n exec			% proc
  } ifelse
} bind def

/FunctionToProc2 % <function_dict> FunctionToProc2 <proc>
{ begin
    currentdict /C0 //knownget exec { length 1 eq } { true } ifelse {
      N
      currentdict /C0 //knownget exec {
	0 get
      } {
        0
      } ifelse
      currentdict /C1 //knownget exec {
	0 get
      } {
        1
      } ifelse
      1 index sub
      [ 4 1 roll
        {		% x n c0 c1-c0
	  4 2 roll	% c0 c1-c0 x n
	  excp mul add	% y
	} aload pop
      ] cvx
    } { 
	[ 
	  0 1 C0 length 1 sub {
	    N						% [ ... i n
            C0 2 index get				% [ ... i n c0
            C1 3 index get				% [ ... i n c0 c1
	    4 3 roll pop				% [ ... n c0 c1
	    1 index sub					% [ ... n c0 c1-c0
	    [ /dup load					% [ ... n c0 c1-c0 [ dup
	      5 2 roll					% [ ... [ dup n c0 c1-c0
	      {			% x x n c0 c1-c0	
	        4 2 roll	% x c0 c1-c0 x n
	        exp mul add	% x y
	        exch		% y x
	      } aload pop
	    ] cvx 
	    /exec load
	  } for
	  /pop load
	] cvx
    } ifelse
  end
  //PDFR_DEBUG {
    (FunctionType2Proc : ) print dup == 
  } if
} bind def


/FunctionToProc4 % <function_dict> FunctionToProc4 <proc>
{ //MakeStreamReader exec cvx run
  //PDFR_DEBUG {
    (FunctionType4Proc : ) print dup == 
  } if
} bind def

/FunctionToProc1 % <function_dict> FunctionToProc <proc>
{ % Assuming a 1-argument function.
  dup /FunctionType get
  { dup 0 eq {
      pop //FunctionToProc10 exec exit
    } if
    dup 2 eq {
      pop //FunctionToProc2 exec exit
    } if
    dup 4 eq {
      pop //FunctionToProc4 exec exit
    } if
    mark exch (Function type ) exch ( isn't implemented yet.) //error exec
  } loop
} bind def

/FunctionToProc % <function_dict> FunctionToProc <proc>
{ //PDFR_DEBUG {
    (FunctionToProc beg ) print count =
  } if
  dup /Domain get length 2 idiv
  {
    dup 1 eq {
      pop //FunctionToProc1 exec exit
    } if
    mark (Functions with many arguments aren't implemented yet.) //error exec
  } loop
  //PDFR_DEBUG {
    (FunctionToProc end ) print count =
  } if
} bind def


% ===================== Color Spaces and Colors ==============

/CheckColorSpace %  <key> <val> CheckColorSpace  <key> <val>
{
  dup type /arraytype ne {
    mark (Resource ) 3 index ( must be an array.) //error exec
  } if
} bind def

/SubstitutePDFColorSpaceRec  % <array> SubstitutePDFColorSpace <array>
{ 0 % Will be bound below
  exec
} bind def

/SubstitutePDFColorSpace % <array> SubstitutePDFColorSpace <array>
{ currentglobal true setglobal exch
  { 
    dup 0 get /Pattern eq {
      dup length 1 gt {
        dup dup 1 //CheckColorSpace //ResolveA exec
	dup type /nametype ne {
          //SubstitutePDFColorSpaceRec exec
	} if
        1 exch put
      } if
      exit
    } if
    dup 0 get /Indexed eq {
      exit
    } if
    dup 0 get /Separation eq {
      dup dup 2 //CheckColorSpace //ResolveA exec
      dup type /nametype ne {
        //SubstitutePDFColorSpaceRec exec
      } if
      2 exch put
      exit
    } if
    dup 0 get /CalGray eq {
      1 get						% dict
      dup /Gamma //knownget exec {
	[ exch /exp load ] cvx
	1 index exch /DecodeLMN exch put
      } if				
      [ exch /CIEBasedA exch ]				% []
      exit
    } if
    dup 0 get /CalRGB eq {
      1 get						% dict
      dup /Matrix //knownget exec { 
	1 index exch /MatrixLMN exch put
      } if
      dup /Gamma //knownget exec {
	aload pop
	[ exch /exp load ] cvx
	3 1 roll
	[ exch /exp load ] cvx
	3 1 roll
	[ exch /exp load ] cvx
	3 1 roll
	3 array astore
	1 index exch /DecodeLMN exch put
      } if				
      [ exch /CIEBasedABC exch ]			% []
      exit
    } if
    dup 0 get /Lab eq {
      1 get						% dict
      begin
        pstack
        currentdict /Range //knownget exec { aload pop } { -100 100 -100 100 } ifelse
	  0 100 6 2 roll 6 array astore 
          /RangeABC exch def
        /DecodeABC [{16 add 116 div} bind {500 div} bind {200 div} bind] def
        /MatrixABC [1 1 1 1 0 0 0 0 -1] def
        { dup 6 29 div ge {dup dup mul mul} {4 29 div sub 108 841 div mul} ifelse }
        /DecodeLMN [
          % Store white point implicitly inside procedures.
          [ 3 index aload pop WhitePoint 0 get /mul load ] cvx
          [ 4 index aload pop WhitePoint 1 get /mul load ] cvx
          [ 5 index aload pop WhitePoint 2 get /mul load ] cvx
        ] def pop
	//PDFR_DEBUG {
	  (Constructed from Lab <<) =
	  currentdict { exch = == } forall
	  (>>) =
	} if
        [ /CIEBasedABC currentdict ]			% []
      end
      exit
      pop
    } if
    mark exch (Unimplemented color space ) exch //error exec
  } loop
  exch setglobal
} bind def

//SubstitutePDFColorSpaceRec 0 //SubstitutePDFColorSpace put

/ResolveArrayElement  % <array> <index> ResolveArrayElement <array>
{ 2 copy get xcheck {
    2 copy get exec
    2 index 4 1 roll put
  } {
    pop
  } ifelse
} bind def

/ResolveColorSpaceArrayRec  % <color_space> ResolveColorSpaceArrayRec <color_space>
{ 0 % Will be bond below.
  exec
} bind def


/ResolveColorSpaceArray  % <color_space> ResolveColorSpaceArray <color_space>
{
  dup 0 get /Indexed eq {
    1 //ResolveArrayElement exec
    dup dup 1 get 
    dup type /arraytype eq {
      //SubstitutePDFColorSpace exec 
      //ResolveColorSpaceArrayRec exec
      1 exch put
    } {
      pop pop
    } ifelse
  } if
  dup 0 get /Separation eq {
    3 //ResolveArrayElement exec
    dup 3 get //FunctionToProc exec
    2 copy 3 exch put
    pop
  } if
  PDFR_DEBUG {
    (Construcrted color space :) =
    dup ==
  } if
} bind def

//ResolveColorSpaceArrayRec 0 //ResolveColorSpaceArray put

/ResolveColorSpace  % <name> ResolveColorSpace <color_space>
{ 
  //PDFR_DEBUG {
    (ResolveColorSpace beg ) print dup =
  } if
  dup //SimpleColorSpaceNames exch known not {
    dup //PDFColorSpaces exch //knownget exec {
      exch pop
      //PDFR_DEBUG {
	(ResolveColorSpace known ) =
      } if
    } {
      dup						% n n
      //PDFReader /CurrentObject get /Context get /Resources get 
      /ColorSpace //DoNothing //ResolveD exec
      exch //CheckColorSpace //ResolveD exec		% n cs
      dup type /arraytype eq {
	//SubstitutePDFColorSpace exec
	//ResolveColorSpaceArray exec
	dup //PDFColorSpaces 4 2 roll put		% []
      } if
    } ifelse
  } if
  //PDFR_DEBUG {
	(ResolveColorSpace end ) print dup ==
  } if
} bind def

/CheckPattern %  <key> <val> CheckPattern  <key> <val>
{
  dup /PatternType //knownget exec {
    dup 1 ne {
      mark (Resource ) 4 index ( is a shading, which can't be handled at level 2. ) //error exec
    } if
    pop
  } if
  dup /Type get /Pattern ne {
    mark (Resource ) 4 index ( must have /Type/Pattern .) //error exec
  } if
} bind def

/PaintProc % 
{ /Context get						% pattern_object
  //RunDelayedStream exec
} bind def

/ResolvePattern % <name> ResolvePattern <pattern>
{
  dup							% n n
  % Since makepattern makes a local dictionary,
  % we cahche them in userdict, which is in local VM.
  % Assuming unique resource name through the document
  userdict /PDFR_Patterns get				% n n d
  exch //knownget exec {				% n p
    exch pop						% p
  } {							% n
    dup 						% n n
    //PDFReader /CurrentObject get /Context get /Resources get 
    /Pattern //DoNothing //ResolveD exec
    exch //CheckPattern //ResolveD exec 		% n o
    dup dup /Context exch put
    dup /Resources //DoNothing //ResolveD exec pop
    dup /PaintProc //PaintProc put
    dup /Matrix get
    gsave userdict /PDFR_InitialGS get setgstate
    makepattern 					% n p
    grestore
    dup userdict /PDFR_Patterns get			% n p p d
    4 2 roll						% p d n p
    put 						% p
  } ifelse
} bind def

/SetColor % Same arguments and result as for scn
{ //PDFR_DEBUG {
    (SetColor beg) =
  } if
  currentcolorspace dup type /nametype eq {
    pop setcolor    
  } {
    0 get /Pattern eq {
      //ResolvePattern exec setpattern
    } {
      setcolor
    } ifelse
  } ifelse
  //PDFR_DEBUG {
    (SetColor beg) =
  } if
} bind def

% ===================== Images ===============================

/ImageKeys 15 dict begin
  /BPC /BitsPerComponent def
  /CS /ColorSpace def
  /D /Decode def
  /DP /DecodeParms def
  /F /Filter def
  /H /Height def
  /IM /ImageMask def
  % /Intent is undefined - pdfwrite must take care of.
  /I /Interpolate def
  /W /Width def
currentdict end readonly def

/ImageValues 15 dict begin
  /G   /DeviceGray def
  /RGB /DeviceRGB def
  /CMYK /DeviceCMYK def 
  /I   /Indexed def
  /AHx /ASCIIHexDecode def
  /A85 /ASCII85Decode def
  /LZW /LZWDecode def
  /Fl  /FlateDecode def
  /RL  /RunLengthDecode def
  /CCF /CCITTFaxDecode def
  /DCT /DCTDecode def
currentdict end readonly def

/DecodeArrays 15 dict begin
  /DeviceGray { [0 1] } def
  /DeviceRGB { [0 1 0 1 0 1] } def
  /DeviceCMYK { [0 1 0 1 0 1 0 1] } def 
  /Indexed { dup /ColorSpace get 2 get [ exch 0 exch ] } def
  /Separation { [0 1] } def
  /CIEBasedA { [0 1] } def
  /CIEBasedABC { [0 1 0 1 0 1] } def
currentdict end readonly def

/Substitute % <key> <dict> Substitute <key>
{ 1 index //knownget exec {
    exch pop
  } if
} bind def

/DebugImagePrinting  % <image_dict> DebugImagePrinting <image_dict>
{
  //PDFR_DEBUG {
    (Image :) =
    dup { exch //=only exec ( ) print == 
    } forall
  } if
} bind def

/CompleteImage	% <dict> CompleteInlineImage <image_dict>
{
  dup /Decode known not {
    dup /ColorSpace //knownget exec { 
      dup type /arraytype eq {
	0 get
      } if
      //DecodeArrays exch get exec 
    } {
      [0 1]
    } ifelse
    1 index exch /Decode exch put
  } if
  dup /ImageMatrix [2 index /Width get 0 0 5 index /Height get neg 
					0 7 index /Height get] put % Not sure why upside down ?
  dup /Filter known {
    dup dup dup /DataSource get
    exch //AppendFilters exec
    /DataSource exch put
  } if
  //DebugImagePrinting exec
} bind def

/CompleteInlineImage  % <dict> CompleteInlineImage <image_dict>
{
  dup /ImageType known not {
    dup /ImageType 1 put
  } if
  dup length dict exch {			    % d key val
    exch //ImageKeys //Substitute exec
    dup /Filter eq {
      exch //ImageValues //Substitute exec exch
    } if
    dup /ColorSpace eq {
      exch 
      dup //ImageValues exch //knownget exec {
	exch pop
      } {
	//ResolveColorSpace exec
      } ifelse
      exch
    } if
    exch
    2 index 3 1 roll put
  } forall
  //CompleteImage exec
} bind def

/CompleteOutlineImage  % <dict> CompleteOutlineImage <image_dict>
{ 
  dup /ImageType known not {
    dup /ImageType 1 put
    dup /ColorSpace known {
      dup /ColorSpace //CheckColorSpace //ResolveD exec
      dup type /arraytype eq {
	//ResolveColorSpaceArray exec
	//SubstitutePDFColorSpace exec
	1 index exch /ColorSpace exch put
      } {
	pop
      } ifelse
    } if
    //CompleteImage exec
  } if
  dup dup //MakeStreamReader exec /DataSource exch put
  % todo: ResetStreamReader if DataSource already exists.
} bind def

/DoImage % <image_dict> DoImage -
{
  gsave
  dup /ColorSpace //knownget exec { setcolorspace } if
  dup /ImageMask //knownget exec not { false } if
  { imagemask } { image } ifelse 
  grestore
} bind def

% ===================== Viewer State ===============

/GSave % - GSave -
{
  gsave
  //PDFReader /GraphicStateStackPointer get
  dup //GraphicStateStack exch get null eq {
    dup //GraphicStateStack exch //InitialGraphicState length dict put 
  } if
  dup //GraphicStateStack exch get
  //GraphicState exch copy pop
  1 add //PDFReader exch /GraphicStateStackPointer exch put
} bind def

/GRestore % - GRestore -
{
  grestore
  //PDFReader /GraphicStateStackPointer get
  1 sub dup
  //PDFReader exch /GraphicStateStackPointer exch put
  //GraphicStateStack exch get
  //GraphicState copy pop
} bind def


% ===================== Interpret Data Streams ===============

/SetFont  % <resource_name> <size> SetFont -
{ dup //GraphicState exch /FontSize exch put
  //ResolveAndSetFont exec
} bind def

/ShowText  % <string> ShowText -
{ //GraphicState /TextRenderingMode get 0 eq {
    //GraphicState /CharacterSpacing get 0
    32
    //GraphicState /WordSpacing get 0
    6 5 roll awidthshow
  } {
    //GraphicState /CharacterSpacing get 0 eq
    //GraphicState /WordSpacing get 0 eq and {
      true charpath
    } {
      % Emulate with "{ charpath } cshow".
      % Not sure how it works with CID fonts.
      { 						% c wx wy
	currentpoint 5 4 roll				% wx wy x y c
	( ) dup 0 3 index put true charpath		% wx wy x y c
	5 1 roll					% c wx wy x y
	moveto rmoveto					% c
	//GraphicState /CharacterSpacing get 0 rmoveto	% c
	32 eq { 					%
	  //GraphicState /WordSpacing get 0 rmoveto
	} if
      }
      exch cshow
    } ifelse
  } ifelse
} bind def

/ShowTextBeg  % - ShowTextBeg -
{ //GraphicState /TextRenderingMode get 0 ne {
	currentpoint newpath moveto
  } if
} bind def

/ShowTextEnd  % - ShowTextEnd -
{ //GraphicState /TextRenderingMode get
  { dup 1 eq {
      stroke exit
    } if
    dup 2 eq {
      gsave fill grestore stroke exit
    } if
    dup 3 eq {
      currentpoint newpath moveto
    } if
    dup 4 eq {
      gsave fill grestore clip exit
    } if
    dup 5 eq {
      gsave stroke grestore clip exit
    } if
    dup 6 eq {
      gsave fill grestore gsave stroke grestore fill exit
    } if
    dup 7 eq {
      clip exit
    } if
    exit
  } loop
  pop
} bind def

/ShowTextWithGlyphPositioning % <array> ShowTextWithGlyphPositioning -
{ //ShowTextBeg exec
  { dup type /stringtype eq {
      //ShowText exec
    } {
      neg 1000 div //GraphicState /FontSize get mul 0 rmoveto
    } ifelse
  } forall
  //ShowTextEnd exec
} bind def

/CheckFont % key val CheckFont key val
{ dup /Type get /ExtGState ne {
    mark (Resource ) 3 index ( must have /Type/ExtGState.) //error exec
  } if
} bind def

/SetTransfer % <operand> SetTransfer -
{
  dup /Identity eq {
    pop {} settransfer
  } {
    dup type /arraytype eq {
      0 4 getinterval aload pop 
      FunctionToProc1x1 4 1 roll
      FunctionToProc1x1 4 1 roll
      FunctionToProc1x1 4 1 roll
      FunctionToProc1x1 4 1 roll
      setcolortransfer
    } {
      FunctionToProc1x1
      settransfer
    } ifelse
  } iflese
} bind def

/CheckExtGState % <id> <obj> CheckExtGState <id> <obj>
{ dup /Type get /ExtGState ne {
    mark (Resource ) 3 index ( must have /Type/ExtGState.) //error exec
  } if
} bind def

/CheckHalftone % <id> <obj> CheckHalftone <id> <obj>
{ dup /HalftoneType known not {
    mark (Resource ) 3 index ( must have /HalftoneType.) //error exec
  } if
} bind def

/SetExtGState % <name> SetExtGState -
{
  //PDFReader /CurrentObject get /Context get /Resources get 
  /ExtGState //DoNothing //ResolveD exec
  exch //CheckExtGState //ResolveD exec 	% s gs
  dup /LW //knownget exec {
    setlinewidth
  } if
  dup /LC //knownget exec {
    setlinecap
  } if
  dup /LJ //knownget exec {
    setlinejoin
  } if
  dup /ML //knownget exec {
    setmeterlimit
  } if
  dup /D //knownget exec {
    setdash
  } if
  dup /RI //knownget exec {
    % Ghostscript never writes it.
    mark (Unimplemented ExtGState.RI) //error exec
  } if
  dup /OP //knownget exec {
    % pdfwrite must take care of stroking/filling
    setoverprint
  } if
  dup /op //knownget exec {
    setoverprint
  } if
  dup /OPM //knownget exec {
    % pdfwrite must take care of.
    mark (Unimplemented ExtGState.OPM) //error exec
  } if
  dup /Font //knownget exec {
    % Ghostscript never writes it.
    mark (Unimplemented ExtGState.Font) //error exec
  } if
  dup /BG //knownget exec {
    setblackgeneration
  } if
  dup /BG2 //knownget exec {
    dup /Default eq {
      //InitialExtGState /BG2 get
    } if
    setblackgeneration
  } if
  dup /UCR //knownget exec {
	setundercolorremoval
  } if
  dup /UCR2 //knownget exec {
    dup /Default eq {
      //InitialExtGState /UCR2 get
    } if
    setundercolorremoval
  } if
  dup /TR //knownget exec {
    //SetTransfer exec
  } if
  dup /TR2 //knownget exec {
    dup /Default eq {
      pop //InitialExtGState /TR2 get
      aload pop setcolortransfer
    } {
      //SetTransfer exec
    } ifelse
  } if
  dup /HT //knownget exec {
    dup /Default eq {
      pop //InitialExtGState /HT get
      sethalftone
    } {
      pop dup /HT //CheckHalftone //ResolveD exec
      sethalftone
    } ifelase
  } if
  dup /FL //knownget exec {
    setflattness
  } if
  dup /SM //knownget exec {
    setsmoothness
  } if
  dup /SA //knownget exec {
    setstrokeadjust
  } if
  dup /BM //knownget exec {
    % pdfwrite must take care of.
    mark (Unimplemented ExtGState.BM) //error exec
  } if
  dup /SMask //knownget exec {
    % pdfwrite must take care of.
    mark (Unimplemented ExtGState.SMask) //error exec
  } if
  dup /CA //knownget exec {
    % pdfwrite must take care of.
    mark (Unimplemented ExtGState.CA) //error exec
  } if
  dup /ca //knownget exec {
    % pdfwrite must take care of.
    mark (Unimplemented ExtGState.ca) //error exec
  } if
  dup /AIS //knownget exec {
    % pdfwrite must take care of.
    mark (Unimplemented ExtGState.AIS) //error exec
  } if
  dup /TK //knownget exec {
    % pdfwrite must take care of.
    mark (Unimplemented ExtGState.TK) //error exec
  } if
  pop
} bind def

/CheckXObject  % <id> <obj> CheckHalftone <id> <obj>
{ dup /Subtype get dup /Image ne exch dup /Form ne exch /PS ne and and {
    mark (Resource ) 3 index ( must have /Subtype /Image or /Form or /PS.) //error exec
  } if
} bind def

/DoXObject % <name> DoXObject -
{
  //PDFReader /CurrentObject get /Context get /Resources get 
  /XObject //DoNothing //ResolveD exec
  exch //CheckXObject //ResolveD exec
  dup /Subtype get
  dup /Image eq {
    pop
    //CompleteOutlineImage exec
    //DoImage exec
  } {
    mark exch (unimplemented XObject type ) exch //error exec
  } ifelse
} bind def

/Operators 50 dict begin
  /q { //GSave exec } bind def
  /Q { //GRestore exec } bind def
  /cm { //TempMatrix astore concat } bind def
  /i { 1 .min setflat } bind def
  /J /setlinecap load def
  /d /setdash load def
  /j /setlinejoin load def
  /w /setlinewidth load def
  /M /setmiterlimit load def
  /gs { SetExtGState } bind def

  /g /setgray load def
  /rg /setrgbcolor load def
  /k /setcmykcolor load def
  /cs { //ResolveColorSpace exec setcolorspace } bind def
  /sc /setcolor load def
  /scn { //SetColor exec } bind def
  /G /setgray load def
  /RG /setrgbcolor load def
  /K /setcmykcolor load def
  /CS { //ResolveColorSpace exec setcolorspace } bind def
  /ri { SetColorRenderingIntent } bind def
  /SC /setcolor load def
  /SCN { //SetColor exec } bind def

  /m /moveto load def
  /l /lineto load def
  /c /curveto load def
  /v { currentpoint 6 2 roll curveto } bind def
  /y { 2 copy curveto } bind def
  /re {
    4 2 roll moveto  exch dup 0 rlineto  0 3 -1 roll rlineto  neg 0 rlineto
    closepath
  } def
  /h /closepath load def
  /n /newpath load def
  /S /stroke load def
  /s { closepath stroke } bind def
  /f /fill load def
  /f* /eofill load def
  /B { gsave fill grestore stroke } bind def
  /b { closepath gsave fill grestore stroke } bind def
  /B* { gsave eofill grestore stroke } bind def
  /b* { closepath gsave eofill grestore stroke } bind def
  /W /clip load def
  /W* /eoclip load def
  /sh { ResolveShading shfill } bind def

  /Do { //DoXObject exec } bind def

  /BI { currentglobal false setglobal << } bind def
  /ID { >>
	dup /DataSource currentfile put
	//CompleteInlineImage exec
	exch setglobal
	//DoImage exec
      } bind def
  /EI {} bind def

  /BT { gsave //GraphicState /InitialTextMatrix get currentmatrix pop } bind def
  /ET { grestore } bind def
  /Tc { //GraphicState exch /CharacterSpacing exch put } bind def
  /TL { //GraphicState exch /TextLeading exch put } bind def
  /Tr { //GraphicState exch /TextRenderingMode exch put } bind def
  /Ts {  % Ghostscript never generates it.
	mark (Unimplemented SetTextRise) //error exec
      } bind def
  /Tw { //GraphicState exch /WordSpacing exch put } bind def
  /Tz { % Ghostscript never generates it.
	    mark (Unimplemented SetHorizontalTextScaling) //error exec
      } bind def
  /Td { translate 0 0 moveto } bind def
  /TD { dup neg //TL exec //Td exec } bind def
  /Tm { //GraphicState /InitialTextMatrix get setmatrix
	//TempMatrix astore concat
	0 0 moveto } bind def
  /T* { 0 //GraphicState /TextLeading get //Td exec } bind def
  /Tj { //ShowTextBeg exec  //ShowText exec  //ShowTextEnd exec } bind def
  /'  { //T* exec //ShowText exec } bind def
  /"  { 3 2 roll //Tw exec exch //Tc exec //' exec} bind def
  /TJ //ShowTextWithGlyphPositioning def
  /Tf //SetFont def

  /d0 /setcharwidth load def
  /d1 /setcachedevice load def

  /BDC { BeginMarkedContentSequenceWithPropertyList } bind def
  /BMC { BeginMarkedContentSequence } bind def
  /EMC { EndMarkedContentSequence } bind def
  /BX { BeginCompatibilitySection } bind def
  /EX { EndCompatibilitySection } bind def
  /DP { DefineMarkedContentPointWithPropertyList } bind def
  /MP { DefineMarkedContentPoint } bind def
currentdict end def

//PDFR_STREAM {
  % Rebind operators with a debug tracing.
  //Operators length dict begin
  //Operators { 				% n p
    exch dup					% p n n
    [ exch //=only /exec load			% p n [ n =only exec
      ( ) /print load				% p n [ n =only exec () print
      8 7 roll					% n [ n =only exec () print p
      dup type /arraytype eq {
	/exec load				% n [ n =only exec () print p exec
      } if
      ( ) /print load
    ] cvx					% n {}
    def
  } forall
  currentdict end /Operators exch def
} if

% Leaving the procset on the dictionary stack to provide 
% definitions of obj, endobj, stream, endstream, R, xref.
%%EndPrologue
