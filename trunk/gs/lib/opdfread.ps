%!PS-Adobe-2.0
%
%	 Copyright (C) 2002 artofcode LLC.	All rights reserved.
% 
% This software is provided AS-IS with no warranty, either express or
% implied.
% 
% This software is distributed under license and may not be copied,
% modified or distributed except as expressly authorized under the terms
% of the license contained in the file LICENSE in this distribution.
% 
% For more information about licensing, please refer to
% http://www.ghostscript.com/licensing/. For information on
% commercial licensing, go to http://www.artifex.com/licensing/ or
% contact Artifex Software, Inc., 101 Lucas Valley Road #110,
% San Rafael, CA  94903, U.S.A., +1(415)492-9861.

% $Id$
% pdfread.ps - A procset for interpreting an ordered PDF 1.3 file.

% This module defines routines for interpreting a PDF file with
% a Postscript interpreter. To convert a PDF file into Postscript 
% just pre-contcatenate this file. The PDF file must satisfy 
% few constraints :
%
% 1. It must contain only Postscript level 2 objects encoded with
% the PDF 1.3 language. Higher PDF levels must be re-distilled
% with CompatibilityLevel=1.3 .
%
% 2. Objects must be ordered so that any resource be defined before
% its usage.
%
% 3. The PDF file must not include other PDF files.
% Consequently we have a single instance of the PDF reader.
% We use this fact to simplify binding of the routines.
% 
% 4. The PDF root object must always have the object id 1.
% 
% 5. Generations besides 0 are not allowed.
%
% 6. xref must appear after all objects.
%
% Assuming the currentfile isn't positionable.
% As a consequence, the reader fully ignores xref.


% !!!!!!!!!!!!!  THIS REVISION IS INCOMPLETE !!!!!!!!!!!!!!!!!!!!
% It only reads a PDF, but it does not do any attempt to interprete it.


true setglobal
30 dict begin

% ===================== Debugging =========================================

/DefaultSwitch	% <name> DefaultSwitch -
{
  dup where {
	pop pop
  } {
	false def
  } ifelse
} bind def

/=string 256 string def

/=only {
  //=string cvs print
} bind def

/PDFR_DEBUG DefaultSwitch
/PDFR_DUMP DefaultSwitch
/PDFR_STREAM DefaultSwitch

/error	%  mark <object> .... error -
{ % A stub for a while.
  counttomark 1 sub -1 0 {
	index =only
  } for
  (\nostack contains :) =
  cleartomark
  % Assuming ....Undefined is never defined. 
  % Use it to emit an error.
  ....Undefined
} bind def

% ===================== Utilities =========================================

/knownget % <dict> <key> knownget <value> true
          % <dict> <key> knownget false
{
  2 copy known {
    get true
  } {
    pop pop false
  } ifelse
} bind def

% ===================== Work Data =========================================

/BlockBuffer 4096 string def
/PDFReader currentdict def
/ObjectRegistry 50 array def % may grow later
/CurrentObject null def
/DoneDocumentStructure false def

% ===================== Reading PDF objects ===============================

/Register % <DefaultDaemon> <id> <obj> Register -
{
  exch dup															% d obj id id
  //PDFReader /ObjectRegistry get length gt {
	//PDFReader /ObjectRegistry get length dup dup 2 div add array	% d obj id length []
	dup 3 1 roll													% d obj id [] length []
	exch 0 exch getinterval 										% d obj id [] []
	//PDFReader /ObjectRegistry get exch copy pop					% d obj id []
	//PDFReader /ObjectRegistry exch put							% d obj id
  } if
  exch //PDFReader /ObjectRegistry get								% d id obj r
  3 1 roll															% d r id obj
  3 copy pop get													% d r id obj e
  dup xcheck {														% d r id obj e
	5 4 roll pop													% r id obj e
	% We've got a definition daemon, execute it :
	exec
  } {																% d r id obj e
	  dup null ne { 												% d r id obj e
		mark (The object ) 4 index ( already defined : ) 4 index //error exec
	} {
	  pop
	} ifelse
	4 3 roll														% r id obj d
	% Execute the default daemon :
	exec
  } ifelse															% r id obj
  put																%
} bind def

/GetRegistered % <id> GetRegistered <obj>
{
  //PDFReader /ObjectRegistry get									% id r
  dup length														% id r l
  2 index le {														% id r
	exch mark exch (Object ) exch ( isn't defined before needed (1).) //error exec 
  } if
  1 index get														% id e
  dup xcheck {
	exch mark exch (Object ) exch ( isn't defined before needed (2).) //error exec 
  } { dup null eq {
		exch mark exch (Object ) exch ( isn't defined before needed (3).) //error exec 
	  } if
	  exch pop														% e
  } ifelse

} bind def

/R % <id> <gen> R <daemon>
{ % Make a reference daemon.
  0 ne {
	exch mark exch (A referred object generation ) exch ( isn't 0.) //error exec
  } if																% id
  [ % <id> proc <obj>
	exch //GetRegistered /exec load 
  ] cvx
  PDFR_DEBUG {
	({ ) print
	dup {
	  =only ( ) print
	} forall
	( }) =
  } if
} bind def

/DoNothing 
{
} def

/RunTypeDaemon  % <id> <obj> RunTypeDaemon <id> <obj>
{
  dup type /dicttype eq {
    dup /Type //knownget exec {
      //PDFReader /TypeDaemons get exch
	  //knownget exec {
	    exec
	  } if
	} if
  } if
} bind def

/obj % <id> <generation> obj <id>
{
  PDFR_DEBUG {
	(Defining ) print 1 index =only ( ) print dup =only ( obj) =
  } if
  0 ne {
	exch mark exch (An object generation ) exch ( isn't 0.) //error exec
  } if
} bind def

/endobj  % <id> <obj> endobj -
{
  PDFR_DEBUG {
	(Storing ) print 1 index =
  } if
  //RunTypeDaemon exec
  //DoNothing 3 1 roll //Register exec
} bind def

/StoreBlock % <buf> StoreBlock -
{ % Stores a (encoded) stream data block to the current object.
  PDFR_DEBUG {
	(StoreBlock ) print //PDFReader /BlockCount get =only (, Length = ) print dup length =
  } if
  dup length string copy
  //PDFReader /BlockCount get exch									% i s
  //PDFReader /CurrentObject get 3 1 roll							% o i s
  put																%
  //PDFReader /BlockCount get 1 add
  //PDFReader exch /BlockCount exch put
} bind def

/CheckLength % <val> CheckNumber <val>
{ dup type /integertype ne {
	mark (Object length isn't an integer.) //error exec
  } if
} bind def

/UnRefD % <dict> <key> <check> UnRefD <value>
{
  3 copy pop get													% <> key {} e
  dup xcheck {
	% We've got a reference daemon, execute it :
	exec															% <> key {} val
  } if
  exch exec 														% <> key val
  dup 4 1 roll														% val <> key val
  put																% val
} bind def

/StoreStream  % <id> <obj> StoreStream <id> <obj>
{ % Stores a (encoded) data stream copy to the current object.
  dup //PDFReader exch /CurrentObject exch put						% id obj
  //PDFReader /BlockCount 0 put
  dup /Length //CheckLength //UnRefD exec							% id obj l
  PDFR_DEBUG {
	(StoreStream Length = ) print dup =
  } if
  currentfile exch () /SubFileDecode filter 						% id obj file
  { dup //BlockBuffer readstring {									% id obj file buf
	  //StoreBlock exec
	} {
	  //StoreBlock exec
	  exit
	} ifelse														% id obj file
  } loop
  pop																% id obj
  //PDFReader /CurrentObject null put
  PDFR_DEBUG {
	(StoreStream end.) =
  } if
} bind def

/ExecuteStream  % <id> <obj> ExecuteStream <id> <obj>
{ % Executes a (encoded) data stream.
  dup //PDFReader exch /CurrentObject exch put						% id obj
  dup /Length //CheckLength //UnRefD exec							% id obj l
  PDFR_DEBUG {
	(ExecuteStream id = ) print 2 index =only ( Length = ) print dup =
  } if
  //PDFReader /InitialGraphicState get 
  //PDFReader /GraphicState get copy pop
  //PDFReader /Operators get begin
  currentfile exch () /SubFileDecode filter 						% id obj file
  cvx mark exch														% id obj mark file
  exec
  counttomark 0 ne {
    mark (Data left on ostack after a stream execution) //error exec
  } if
  cleartomark														% id obj
  end % Operators
  PDFR_DEBUG {
	(ExecuteStream end.) =
  } if
  //PDFReader /CurrentObject null put
  showpage
} bind def

/stream  % <id> <obj> stream <id> <obj>
{ 
  PDFR_DEBUG {
	1 index =only ( stream) =
  } if																% id obj
  % Run the object definition daemon, if exists :
  //PDFReader /ObjectRegistry get dup length 3 index                % id obj r l id
  gt {																% id obj r
    2 index get 
	dup xcheck {
	  exec
	  % Disable the daemon :
      //PDFReader /ObjectRegistry get 2 index null put
	} {
	  pop
	} ifelse
  } {
    pop
  } ifelse															% id obj
  dup /ImmediateExec known {
	//ExecuteStream exec
  } {
	//StoreStream exec
  } ifelse
} bind def

/endstream % <id> <obj> endstream <id> <obj>
{ % Nothing to do.
} bind def

/xref % - xref -
{ 
  PDFR_DEBUG {
	(xref) =
	PDFR_DUMP {
	  //PDFReader /ObjectRegistry get ==
	} if
  } if
  end % The procset
  count 0 ne {
	mark (Excessive data on estack at the end of the interpretation.) //error exec
  } if
  currentfile flushfile
} bind def

% ===================== Restoring the PDF Document Structure ===============

/PageContentsDaemon % <id> <obj> <node> PageContentsDaemon <id> <obj>
{ % Note: an excessive operand from a prebond procedure.
  PDFR_DEBUG {
	(Executing PageContentsDaemon for ) print 2 index =
  } if																% id obj node
  1 index exch /Context exch put									% id obj
  dup /ImmediateExec true put
} bind def

/TypeDaemons <<  % <id> <obj> proc <id> <obj>
  /Page 
  { PDFR_DEBUG {
	  (Recognized a page.)=
	} if
	dup /Contents get 0 get	//DoNothing exch 						% id obj dn id1
	[ % <id> <obj> proc <id> <obj>
	  3 index //PageContentsDaemon /exec load
	] cvx															% id obj {}
	//Register exec													% id obj
  } bind
>> def

% ===================== Interpret Data Streams ===============

/TempMatrix matrix def
/InitialExtGState 20 dict begin
  /BG2 currentblackgeneration def
  /UCR2 currentundercolorremoval def
  /TR2 [ currentcolortransfer ] def
  /HT currenthalftone def
currentdict end def
/InitialGraphicState 20 dict begin
  /FontSize 0 def
  /CharacterSpacing 0 def
  /TextLeading 0 def
  /TextRenderingMode 0 def
  /WordSpacing 0 def
currentdict end def
/GraphicState 20 dict begin
  /InitialTextMatrix matrix def
currentdict end def

/CheckFont % key val CheckFont key val
{ dup /Type get /Font ne {
    mark (Resource ) 3 index ( must have /Type/Font.) //error exec
  } if
} bind def

/SetFont  % <resource_name> <size> SetFont -
{ dup //GraphicState exch /FontSize exch put
  exch																% s n 
  //PDFReader /CurrentObject get /Context get /Resources get 
  /Font //DoNothing //UnRefD exec
  exch //CheckFont //UnRefD exec									% s fr
  dup /Subtype get /Type3 eq {
    (Underimplemented SetFont)=
	pop /Courier exch 10 mul selectfont
  } {
    /BaseFont get
    (Underimplemented SetFont)=
    =string cvs (+) search {
      pop pop
    } if
	cvn
	PDFR_DEBUG {
	  (Font ) print dup =
	} if
    exch selectfont
  } ifelse
} bind def

/ShowText  % <string> ShowText -
{ //GraphicState /TextRenderingMode get 0 eq {
    //GraphicState /CharacterSpacing get 0
    32
    //GraphicState /WordSpacing get 0
    6 5 roll awidthshow
  } {
    //GraphicState /CharacterSpacing get 0 eq
    //GraphicState /WordSpacing get 0 eq and {
	  true charpath
	} {
      % Emulate with "{ charpath } cshow".
	  % Not sure how it works with CID fonts.
	  {														% c wx wy
	    currentpoint 5 4 roll								% wx wy x y c
	    dup ( ) exch 0 put true charpath					% wx wy x y c
	    5 1 roll											% c wx wy x y
	    moveto rmoveto										% c
	    //GraphicState /CharacterSpacing get 0 rmoveto		% c
	    32 eq {												%
		  //GraphicState /WordSpacing get 0 rmoveto
	    } if
	  }
      exch cshow
	} ifelse
  } ifelse
} bind def

/ShowTextBeg  % - ShowTextBeg -
{ //GraphicState /TextRenderingMode get 0 ne {
	currentpoint newpath moveto
  } if
} bind def

/ShowTextEnd  % - ShowTextEnd -
{ //GraphicState /TextRenderingMode get
  { dup 1 eq {
      stroke exit
    } if
    dup 2 eq {
      gsave fill grestore stroke exit
    } if
    dup 3 eq {
      currentpoint newpath moveto
    } if
    dup 4 eq {
      gsave fill grestore clip exit
    } if
    dup 5 eq {
      gsave stroke grestore clip exit
    } if
    dup 6 eq {
      gsave fill grestore gsave stroke grestore fill exit
    } if
    dup 7 eq {
      clip exit
    } if
    exit
  } loop
  pop
} bind def

/ShowTextWithGlyphPositioning % <array> ShowTextWithGlyphPositioning -
{ //ShowTextBeg exec
  { dup type /stringtype eq {
      //ShowText exec
    } {
	  neg 1000 div //GraphicState /FontSize get mul 0 rmoveto
	} ifelse
  } forall
  //ShowTextEnd exec
} bind def

/CheckFont % key val CheckFont key val
{ dup /Type get /ExtGState ne {
    mark (Resource ) 3 index ( must have /Type/ExtGState.) //error exec
  } if
} bind def

/SetTransfer % <operand> SetTransfer -
{
  dup /Identity eq {
    pop {} settransfer
  } {
    dup type /arraytype eq {
	  0 4 getinterval aload pop 
	  FunctionToProc11 4 1 roll
	  FunctionToProc11 4 1 roll
	  FunctionToProc11 4 1 roll
	  FunctionToProc11 4 1 roll
	  setcolortransfer
	} {
	  FunctionToProc11
	  settransfer
	} ifelse
  } iflese
} bind def

/CheckExtGState % <id> <obj> CheckExtGState <id> <obj>
{ dup /Type get /ExtGState ne {
    mark (Resource ) 3 index ( must have /Type/ExtGState.) //error exec
  } if
} bind def

/CheckHalftone % <id> <obj> CheckHalftone <id> <obj>
{ dup /HalftoneType known not {
    mark (Resource ) 3 index ( must have /HalftoneType.) //error exec
  } if
} bind def

/SetExtGState % <name> SetExtGState -
{
  //PDFReader /CurrentObject get /Context get /Resources get 
  /ExtGState //DoNothing //UnRefD exec
  exch //CheckExtGState //UnRefD exec							% s gs
  dup /LW //knownget exec {
    setlinewidth
  } if
  dup /LC //knownget exec {
    setlinecap
  } if
  dup /LJ //knownget exec {
    setlinejoin
  } if
  dup /ML //knownget exec {
    setmeterlimit
  } if
  dup /D //knownget exec {
    setdash
  } if
  dup /RI //knownget exec {
    % Ghostscript never writes it.
    mark (Unimplemented ExtGState.RI) //error exec
  } if
  dup /OP //knownget exec {
    % pdfwrite must take care of stroking/filling
    setoverprint
  } if
  dup /op //knownget exec {
    setoverprint
  } if
  dup /OPM //knownget exec {
    % pdfwrite must take care of.
    mark (Unimplemented ExtGState.OPM) //error exec
  } if
  dup /Font //knownget exec {
    % Ghostscript never writes it.
    mark (Unimplemented ExtGState.Font) //error exec
  } if
  dup /BG //knownget exec {
    setblackgeneration
  } if
  dup /BG2 //knownget exec {
    dup /Default eq {
	  //InitialExtGState /BG2 get
	} if
	setblackgeneration
  } if
  dup /UCR //knownget exec {
	setundercolorremoval
  } if
  dup /UCR2 //knownget exec {
    dup /Default eq {
	  //InitialExtGState /UCR2 get
	} if
	setundercolorremoval
  } if
  dup /TR //knownget exec {
	//SetTransfer exec
  } if
  dup /TR2 //knownget exec {
	dup /Default eq {
	  pop //InitialExtGState /TR2 get
	  aload pop setcolortransfer
	} {
	  //SetTransfer exec
	} ifelse
  } if
  dup /HT //knownget exec {
	dup /Default eq {
	  pop //InitialExtGState /HT get
	  sethalftone
	} {
	  pop dup /HT //CheckHalftone //UnRefD exec
	  sethalftone
	} ifelase
  } if
  dup /FL //knownget exec {
	setflattness
  } if
  dup /SM //knownget exec {
	setsmoothness
  } if
  dup /SA //knownget exec {
	setstrokeadjust
  } if
  dup /BM //knownget exec {
    % pdfwrite must take care of.
    mark (Unimplemented ExtGState.BM) //error exec
  } if
  dup /SMask //knownget exec {
    % pdfwrite must take care of.
    mark (Unimplemented ExtGState.SMask) //error exec
  } if
  dup /CA //knownget exec {
    % pdfwrite must take care of.
    mark (Unimplemented ExtGState.CA) //error exec
  } if
  dup /ca //knownget exec {
    % pdfwrite must take care of.
    mark (Unimplemented ExtGState.ca) //error exec
  } if
  dup /AIS //knownget exec {
    % pdfwrite must take care of.
    mark (Unimplemented ExtGState.AIS) //error exec
  } if
  dup /TK //knownget exec {
    % pdfwrite must take care of.
    mark (Unimplemented ExtGState.TK) //error exec
  } if
  pop
} bind def

/Operators 50 dict begin
  /q /gsave load def
  /Q /grestore load def
  /cm { //TempMatrix astore concat } bind def
  /i { 1 .min setflat } bind def
  /J /setlinecap load def
  /d /setdash load def
  /j /setlinejoin load def
  /w /setlinewidth load def
  /M /setmiterlimit load def
  /gs { SetExtGState } bind def

  /g /setgray load def
  /rg /setrgbcolor load def
  /k /setcmykcolor load def
  /cs { ResolveColorSpace setcolorspace } bind def
  /sc /setcolor load def
  /scn  /setcolor load def
  /G /setgray load def
  /RG /setrgbcolor load def
  /K /setcmykcolor load def
  /CS { ResolveColorSpace setcolorspace } bind def
  /ri { SetColorRenderingIntent } bind def
  /SC /setcolor load def
  /SCN /setcolor load def

  /m /moveto load def
  /l /lineto load def
  /c /curveto load def
  /v { currentpoint 6 2 roll curveto } bind def
  /y { 2 copy curveto } bind def
  /re {
    4 2 roll moveto  exch dup 0 rlineto  0 3 -1 roll rlineto  neg 0 rlineto
    closepath
  } def
  /h /closepath load def
  /n /newpath load def
  /S /stroke load def
  /s { closepath stroke } bind def
  /f /fill load def
  /f* /eofill load def
  /B { gsave fill grestore stroke } bind def
  /b { closepath gsave fill grestore stroke } bind def
  /B* { gsave eofill grestore stroke } bind def
  /b* { closepath gsave eofill grestore stroke } bind def
  /W /clip load def
  /W* /eoclip load def
  /sh { ResolveShading shfill } bind def

  /DO { DoXObject } bind def

  /BI { BeginInlineImage } bind def
  /EI { EndInlineImage } bind def
  /ID { BeginInlineData } bind def

  /BT { gsave //GraphicState /InitialTextMatrix get currentmatrix pop } bind def
  /ET { grestore } bind def
  /Tc { //GraphicState exch /CharacterSpacing exch put } bind def
  /TL { //GraphicState exch /TextLeading exch put } bind def
  /Tr { //GraphicState exch /TextRenderingMode exch put } bind def
  /Ts {  % Ghostscript never generates it.
	    mark (Unimplemented SetTextRise) //error exec
	  } bind def
  /Tw { //GraphicState exch /WordSpacing exch put } bind def
  /Tz { % Ghostscript never generates it.
	    mark (Unimplemented SetHorizontalTextScaling) //error exec
      } bind def
  /Td { translate 0 0 moveto } bind def
  /TD { dup neg //TL exec //Td exec } bind def
  /Tm { //GraphicState /InitialTextMatrix get setmatrix
        //TempMatrix astore concat
        0 0 moveto } bind def
  /T* { 0 //GraphicState /TextLeading get //Td exec } bind def
  /Tj { //ShowTextBeg exec  //ShowText exec  //ShowTextEnd exec } bind def
  /' { //T* exec //ShowText exec } bind def
  /" { 3 2 roll //Tw exec exch //Tc exec //' exec} bind def
  /TJ //ShowTextWithGlyphPositioning def
  /Tf //SetFont def

  /d0 /setcharwidth load def
  /d1 /setcachedevice load def

  /BDC { BeginMarkedContentSequenceWithPropertyList } bind def
  /BMC { BeginMarkedContentSequence } bind def
  /EMC { EndMarkedContentSequence } bind def
  /BX { BeginCompatibilitySection } bind def
  /EX { EndCompatibilitySection } bind def
  /DP { DefineMarkedContentPointWithPropertyList } bind def
  /MP { DefineMarkedContentPoint } bind def
currentdict end def

PDFR_STREAM {
  % Rebind operators with a debug tracing.
  //Operators length dict begin
  //Operators {												% n p
	exch dup												% p n n
	[ exch //=only /exec load								% p n [ n =only exec
	  ( ) /print load										% p n [ n =only exec () print
      8 7 roll												% n [ n =only exec () print p
	  dup type /arraytype eq {
	    /exec load											% n [ n =only exec () print p exec
	  } if
	  ( ) /print load
	] cvx													% n {}
	def
  } forall
  currentdict end /Operators exch def
} if

% Leaving the procset on the dictionary stack to provide 
% definitions of obj, endobj, stream, endstream, R, xref.
%%EndPrologue
