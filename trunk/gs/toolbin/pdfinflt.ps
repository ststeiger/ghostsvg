%    Copyright (C) 1992, 1993, 1994, 1995, 1999 Aladdin Enterprises.  All rights reserved.
% 
% This software is provided AS-IS with no warranty, either express or
% implied.
% 
% This software is distributed under license and may not be copied,
% modified or distributed except as expressly authorized under the terms
% of the license contained in the file LICENSE in this distribution.
% 
% For more information about licensing, please refer to
% http://www.ghostscript.com/licensing/. For information on
% commercial licensing, go to http://www.artifex.com/licensing/ or
% contact Artifex Software, Inc., 101 Lucas Valley Road #110,
% San Rafael, CA  94903, U.S.A., +1(415)492-9861.

% $Id$
% pdfinflt.ps
% 
% Try to decompress any FlateDecode streams in the input file.
% 
% Usage: gs -- toolbin/pdfinflt.ps infile outfile
%
% Requires: lib/pdfwrite.ps.
% 
% 
% It is not yet ready for prime time, but it is available for anyone wants
% to fix it.
% 
% The main problems are:
% 
% 1. It doesn't work for files that use chained filters such as
%    [ /ASCII85Decode /FlateDecode ]
% 
% 2. Sometimes the PDF files that are written are broken. When they are
%    broken, GS gets an xref problem.
% 
%    This second problem is actually due to lib/pdfwrite.ps since even
%    when no conversion is done, the file is may be bad.

% Check to make sure both input and output filename was specified.
[ shellarguments
  { counttomark 2 eq {
      % Arguments ok
      /OutFileName exch def
      /InFileName exch def
   
      (pdfwrite.ps) runlibfile
   
      /justcopy /pdfcopystream load def
      /pdfcopystream {		% <newstreamdict> <file> pdfcopystream -
				%   (file has been positioned)
        1 index /Filter knownoget {
          dup type /arraytype eq {
	    % fails for chained filters like [ /ASCII85Decode /FlateDecode ]
            dup length 1 eq { 0 get } if
          } if 
	    /FlateDecode eq {
      		% Decompress the data.  To avoid doing a first pass just to
      		% find its length, we create an indirect object.
            10 dict begin
            /infile exch def /sdict exch def
            RMap length neg omapnew pop /lenobj exch def
            sdict dup length dict copy
            dup /Filter undef dup /DecodeParms undef
            dup /Length lenobj /O cvx 2 packedarray cvx put
            pdfwritevalue (stream\n) ows
            /opos OFile fileposition def
            infile sdict /Length oget () /SubFileDecode filter
            sdict /DecodeParms knownoget pop /FlateDecode filter
            dup OFile 16#7fffffff pdfcopybytes closefile
            /len OFile fileposition opos sub def
            (\nendstream\nendobj\n) ows
            lenobj pdfwriteobjheader len pdfwritevalue
            end
          } {
            justcopy
          } ifelse
        } {
          justcopy
        } ifelse
      } def
   
      { InFileName (r) file } stopped
      { (\n*** Cannot open input file: ) print InFileName print ( ***\n\n) print flush
        quit
      }
      if
      pdfdict begin pdfopen begin
      
      { OutFileName (w) file } stopped
      { (\n*** Cannot open output file: ) print OutFileName print ( ***\n\n) print flush
        quit
      }
      if
      (Converting ) print InFileName print ( to ) print OutFileName = flush
      currentdict /Trailer get
      dup /Prev undef		% We don't want a 'Prev' link.
      pdfwrite
      end end
      (Done.\n) print flush
      cleartomark
      true		% success
    }
    {
      (\n*** Incorrect number of file name arguments. ***\n\n) print
      cleartomark false			% incorrect number of arguments
    }
    ifelse
  }
  {
    (\n*** Missing '--' preceding toolbin/pdfinflt.ps ***\n\n) print
    cleartomark false			% not in shell arguments mode (missing -- )
  }
ifelse 
not {
   (Usage: gs -- toolbin/pdfinflt.ps infile outfile\n\n) print flush
}
if
quit
