<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Ghostscript C coding guidelines</title>
<!-- $Id$ -->
<!-- Originally: c-style.txt -->
<link rel="stylesheet" type="text/css" href="gs.css" title="Ghostscript Style">
</head>

<body>
<!-- [1.0 begin visible header] ============================================ -->

<!-- [1.1 begin headline] ================================================== -->

<h1>Ghostscript C coding guidelines</h1>

<!-- [1.1 end headline] ==================================================== -->

<!-- [1.2 begin table of contents] ========================================= -->

<h2>Table of contents</h2>

<blockquote><ul>
<li><a href="#Introduction">Introduction</a>
<li><a href="#Summary">Summary of the coding guidelines</a>
<ul>
<li><a href="#Summary_preprocessor">Preprocessor</a>
<li><a href="#Summary_types">Types and scopes</a>
<li><a href="#Summary_formatting">Formatting</a>
<li><a href="#Summary_miscellany">Miscellany</a>
</ul>
<li><a href="#Overview">Overview</a>
<li><a href="#C_features">Use of C language features</a>
<ul>
<li>Preprocessor:
    <a href="#Conditionals">Conditionals</a>,
    <a href="#Macros">Macros</a>
<li>Scoping:
    <a href="#Static_extern_scoping"><b><tt>static</tt></b> and <b><tt>extern</tt></b></a>
<li>Data types:
    <a href="#Scalars">Scalars</a>,
    <a href="#Pointers">Pointers</a>,
    <a href="#Structures">Structures</a>
<li><a href="#Standard_library">Standard library features</a>
<li><a href="#Other">Miscellany</a>
</ul>
<li><a href="#File_structuring_naming">File structuring and naming</a>
<ul>
<li><a href="#All_files">All files</a>
<li><a href="#Makefiles">Makefiles</a>
<li><a href="#General_C_code">General C Code</a>
<li><a href="#Headers">Headers (<b><tt>.h</tt></b> files)</a>
<li><a href="#Source">Source (<b><tt>.c</tt></b> files)</a>
</ul>
<li><a href="#Formatting">Formatting</a>
<ul>
<li><a href="#Indentation">Indentation</a>
<li><a href="#Spaces">Spaces</a>
<li><a href="#Parentheses">Parentheses</a>
</ul>
<li><a href="#Naming">Naming</a>
<ul>
<li><a href="#General_naming">General rules</a>
</ul>
<li><a href="#Miscellany">Miscellany</a>
<ul>
<li><a href="#Single_use_procedures">Single-use procedures</a>
<li><a href="#Local_variables">Local variables</a>
<li><a href="#Compiler_warnings">Compiler warnings</a>
</ul>
<li><a href="#Conventions">Ghostscript conventions</a>
<ul>
<li><a href="#Specific_names">Specific names</a>
<ul>
<li><a href="#code"><b><tt>code</tt></b></a>
<li><a href="#status"><b><tt>status</tt></b></a>
</ul>
<li><a href="#Objects">"Objects"</a>
<li><a href="#Error_handling">Error handling</a>
</ul>
</ul></blockquote>

<!-- [1.2 end table of contents] =========================================== -->

<!-- [1.3 begin hint] ====================================================== -->

<p>
For other information, see the <a href="Readme.htm">Ghostscript
overview</a>.

<!-- [1.3 end hint] ======================================================== -->

<hr>

<!-- [1.0 end visible header] ============================================== -->

<!-- [2.0 begin contents] ================================================== -->

<h2><a name="Introduction"></a>Introduction</h2>

<p>
This document describes Ghostscript's C coding conventions.  It is primarily
<strong>prescriptive</strong>, documenting what developers should do when
writing new code; the companion <a href="Develop.htm">Developer
documentation</a> is primarily <strong>descriptive</strong>, documenting the
way things are.

<h2><a name="Summary"></a>Summary of the coding guidelines</h2>

<h3><a name="Summary_preprocessor"></a>Preprocessor</h3>

<ul>
<li>Use preprocessor conditionals that test for individual platforms or
compilers, if necessary, only in header files named xxx<b><tt>_.h</tt></b>.

<li>Don't define a macro if you can do it with a procedure.

<li>Use

<blockquote><b><tt>
gx_device_fubar&nbsp;*&nbsp;const&nbsp;fdev&nbsp;=&nbsp;(gx_device_fubar&nbsp;*)dev;
</tt></b></blockquote>

<p>
rather than

<blockquote><b><tt>
#define&nbsp;fdev&nbsp;((gx_device_fubar&nbsp;*)dev)
</tt></b></blockquote>

<li>Put <b><tt>()</tt></b> around the body of expression-macro definitions,
and around each use of an argument.

<li>Make all variables referenced in a macro body arguments of the macro.
</ul>

<h3><a name="Summary_types"></a>Types and scopes</h3>

<ul>

<li>Use <b><tt>const</tt></b> for pointer referents (that is,
<b><tt>const&nbsp;T&nbsp;*</tt></b>) wherever possible.

<li>Use unions or (less preferably) casts in preference to
<b><tt>void&nbsp;*</tt></b>.

<li>Don't use anonymous structures or unions.

<li>Don't declare procedure parameters of type <b><tt>float</tt></b>,
<b><tt>short</tt></b>, or <b><tt>char</tt></b>.

<li>Never explicitly cast <b><tt>float</tt></b> to <b><tt>double</tt></b>.

<li>Use "<b><tt>private</tt></b>" instead of "<b><tt>static</tt></b>" at
the top level of a file.

<li>Don't create any new non-<b><tt>const</tt></b> static variables.

<li>Put externs in <b><tt>.h</tt></b> files, not <b><tt>.c</tt></b> files.
</ul>

<h3><a name="Summary_formatting"></a>Formatting</h3>

<ul>

<li><b><tt>gsindent</tt></b> (GNU <b><tt>indent</tt></b> + fixup script)
will do 98% of the job for you.

<li>Put indentation points every 4 spaces, with 8 spaces = 1 tab stop.

<li>"<b><tt>{</tt></b>" should always be the last non-blank character on
its line (except for comments); "<b><tt>}</tt></b>" should always be the
first non-blank on its line.

<li>Use spaces after comma ("<b><tt>,</tt></b>") and semicolon
("<b><tt>;</tt></b>"), around binary operators, and on both sides of the
parentheses for <b><tt>if</tt></b>, <b><tt>for</tt></b>, and
<b><tt>while</tt></b>, and nowhere else.

<li>Use parentheses only when mixing <b><tt>&amp;&amp;</tt></b> and
<b><tt>||</tt></b>, when mixing <b><tt>&amp;</tt></b>, <b><tt>|</tt></b>
and shifts with each other or other operators, and around
"<b><tt>?&nbsp;:</tt></b>" expressions.
</ul>

<h3><a name="Summary_miscellany"></a>Miscellany</h3>

<ul>

<li>Use <b><tt>#include</tt></b> statements in the order
<ol>
<li><b><tt>*_.h</tt></b>
<li><b><tt>gs*.h</tt></b>
<li><b><tt>gx*.h</tt></b>
<li><b><tt>s*.h</tt></b>
<li><b><tt>i*.h</tt></b>
</ol>

<li>In names use full words rather than contractions, and don't run words
together.

<li>Don't assign new values to procedure parameters.

<li>Initialize local variables when they are declared.
</ul>

<hr>

<h2><a name="Overview"></a>Overview</h2>

<p>
The many rules that Ghostscript's code follows almost everywhere are meant
to produce code that is easy to read.  It's important to observe them as
much as possible in order to maintain a consistent style, but if you find a
rule getting in your way or producing ugly-looking results once in a while,
it's OK to break it.

<hr>

<h2><a name="C_features"></a>Use of C language features</h2>

<h3><a name="Conditionals"></a>Preprocessor Conditionals</h3>

<p>
Using preprocessor conditionals can easily lead to unreadable code, since
the eye really wants to read linearly rather than having to parse the
conditionals just to figure out what code is relevant.  It's OK to use
conditionals that have small scope and that don't change the structure or
logic of the program (typically, they select between different sets of
values depending on some configuration parameter), but where possible, break
up source modules rather than use conditionals that affect the structure or
logic.

<p>
In <b><tt>.c</tt></b> files don't use preprocessor conditionals that
test for individual platforms or compilers.  Use them only in header
files named xxx<b><tt>_.h</tt></b>.

<h3><a name="Macros"></a>Preprocessor Macros</h3>

<p>
Ghostscript code uses macros heavily to effectively extend the rather
weak abstraction capabilities of the C language, specifically in the area of
memory management and garbage collection: in order to read Ghostscript code
effectively, you simply have to learn some of these macros as though they
were part of the language.  The current code also uses macros heavily for
other purposes, but we are trying to phase these out as rapidly as possible,
because they make the code harder to read and debug, and to use the
rules that follow consistently in new code.

<p>
Define macros in the smallest scope you can manage (procedure, file, or
<b><tt>.h</tt></b> file), and <b><tt>#undef</tt></b> them at the end of
that scope: that way, someone reading the code can see the definitions
easily when reading the uses.  If that isn't appropriate, define them in as
large a scope as possible, so that they effectively become part of the
language.  This places an additional burden on the reader, but it can be
amortized over reading larger amounts of code.

<p>
Try hard to use procedures instead of macros.  Use "<b><tt>inline</tt></b>"
if you really think the extra speed is needed, but only within a
<b><tt>.c</tt></b> file: don't put inline procedures in <b><tt>.h</tt></b>
files, because most compilers don't honor "<b><tt>inline</tt></b>" and
you'll wind up with a copy of the procedure in every <b><tt>.c</tt></b>
file that includes the <b><tt>.h</tt></b> file.

<p>
Don't use macros to define shorthands for casted pointers.  For instance,
avoid

<blockquote><b><tt>
#define fdev ((gx_device_fubar *)dev)
</tt></b></blockquote>

<p>
and instead use

<blockquote><b><tt>
gx_device_fubar * const fdev = (gx_device_fubar *)dev;
</tt></b></blockquote>

<p>
The use of <b><tt>const</tt></b> alerts the reader that this is effectively
a synonym.

<p>
If you define a macro that looks like a procedure, make sure it will work
wherever a procedure will work.  In particular, put parentheses around every
use of an argument within the macro body, so that the macro will parse
correctly if some of the arguments are expressions, and put parentheses
around the entire macro body.  (This is still subject to the problem that an
argument may be evaluated more than once, but there is no way around this in
C, since C doesn't provide for local variables within expressions.)

<p>
If a macro generates anything larger than a single expression (that is, one
or more statements), surround it with <b><tt>BEGIN</tt></b> and
<b><tt>END</tt></b>.  These work around the fact that simple statements and
compound statements in C can't be substituted for each other syntactically.

<p>
If you define macros for special loop control structures, make their uses
look somewhat like ordinary loops, for instance:

<blockquote>
<b><tt>BEGIN_RECT(xx, yy) {</tt></b><br>
&nbsp;&nbsp;... body indented one position ...<br>
<b><tt>} END_RECT(xx, yy);</tt></b>
</blockquote>

<p>
If at all possible, don't use free variables in macros -- that is, variables
that aren't apparent as arguments of the macro.  If you must use free
variables, list them all in a comment at the point where the macro is
defined.

<p>
Preferably <b><tt>CAPITALIZE</tt></b> macro names.

<h3><a name="Static_extern_scoping"></a>Static and extern scoping</h3>

<p>
Use "<b><tt>private</tt></b>" instead of "<b><tt>static</tt></b>" for
constructs (procedures and variables) declared at the outermost scope of a
file.  This allows making such constructs either visible or invisible to
profilers with a single changed <b><tt>#define</tt></b>.

<p>
Don't create any new non-<b><tt>const</tt></b> static variables (whether
exported or local to a file): they are incompatible with reentrancy, and
we're in the process of eliminating all of them.

<p>
Avoid <b><tt>extern</tt></b> in <b><tt>.c</tt></b> files: put it in header
files.

<h3><a name="Scalars"></a>Scalars</h3>

<p>
Even though <b><tt>bool</tt></b> is a synonym for <b><tt>int</tt></b>, treat
them as conceptually different types:

<ul>
<li>Initialize or set <b><tt>bool</tt></b> variables to <b><tt>true</tt></b>
or <b><tt>false</tt></b>, not 0 or 1.
<li>Use the Boolean operators <b><tt>!</tt></b>, <b><tt>&&</tt></b>,
and <b><tt>||</tt></b> only with Booleans.  Don't use the idiom
<b><tt>!!x</tt></b> to create a Boolean that is true iff <b><tt>x</tt></b>
!= 0: use <b><tt>x != 0</tt></b>.
<li>Use an explicit <b><tt>(int)</tt></b> cast to convert a Boolean to an
integer.
</ul>

<p>
Don't declare parameters as being of type <b><tt>float</tt></b>,
<b><tt>short</tt></b>, or <b><tt>char</tt></b>.  If you do this and forget
to include the prototype at a call site, ANSI compilers will generate
incompatible calling sequences.  Use <b><tt>floatp</tt></b> (a synonym for
<b><tt>double</tt></b>, mnemonic for "float parameter") instead of
<b><tt>float</tt></b>, and use <b><tt>int</tt></b> or <b><tt>uint</tt></b>
instead of <b><tt>short</tt></b> or <b><tt>char</tt></b>.

<p>
ANSI compilers in their default mode do all floating point computations in
double precision, so never cast a <b><tt>float</tt></b> to a
<b><tt>double</tt></b> explicitly.

<p>
Unless there's a good reason for doing otherwise, return
<b><tt>floatp</tt></b> (<b><tt>double</tt></b>) rather than
<b><tt>float</tt></b> values.  Floating point hardware often does everything
in double precision internally and has to do extra work to convert between
double and single precision.

<h3><a name="Pointers"></a>Pointers</h3>

<p>
Use <b><tt>const</tt></b> for pointer referents (that is,
<b><tt>const&nbsp;T&nbsp;*</tt></b>) wherever possible and appropriate.

<p>
If you find yourself wanting to use <b><tt>void&nbsp;*</tt></b>, try to
find an alternative using unions or (in the case of super- and subclasses)
casts, unless you're writing something like a memory manager that really
treats memory as opaque.

<p>
If a procedure parameter is itself a procedure, do list its
parameter types rather than just using <b><tt>()</tt></b>.  For example,

<blockquote><b><tt>
int foo(P1(int (*callback)(P2(int, int))));
</tt></b></blockquote>

<p>
rather than just

<blockquote><b><tt>
int foo(P1(int (*callback)()));
</tt></b></blockquote>

<h3><a name="Structures"></a>Structures</h3>

<p>
Don't use anonymous structures if you can possibly avoid it, except
occasionally as components of other structures. Ideally, use the
<b><tt>struct</tt></b> keyword only for declaring named structure types,
like this:

<blockquote>
<b><tt>typedef struct xxx_s {</tt></b><br>
&nbsp;&nbsp;&nbsp;... members ...<br>
<b><tt>} xxx_t;</tt></b>
</blockquote>

<p>
In any case, use <b><tt>struct</tt></b> only when declaring structure types,
never for referring to them (e.g., never declare a variable as type
<b><tt>struct&nbsp;xxx_s&nbsp;*</tt></b>).

<p>
Many older structure names don't have <b><tt>_t</tt></b> on the end, but
this suffix should be used in all new code.  (The <b><tt>_s</tt></b>
structure name is needed only to satisfy some debuggers.  No code other than
the structure declaration should refer to it.)

<p>
Don't assume that the compiler will (or won't) insert padding in structures
to align members for best performance.  To preserve alignment, only declare
structure members that are narrower than an <b><tt>int</tt></b> if there
will be a lot of instances of that structure in memory.  For such
structures, insert <b><tt>byte</tt></b> and/or <b><tt>short</tt></b> padding
members as necessary to re-establish <b><tt>int</tt></b> alignment.

<p>
Declare structure types that contain pointers to other instances of
themselves like this:

<blockquote>
<b><tt>typedef struct xxx_s xxx_t;</tt></b><br>
<b><tt>struct xxx_s {</tt></b><br>
&nbsp;&nbsp;&nbsp;... members ...<br>
&nbsp;&nbsp;&nbsp;<b><tt>xxx_t *</tt></b>ptr_member_name;<br>
&nbsp;&nbsp;&nbsp;... members ...<br>
<b><tt>};</tt></b>
</blockquote>

<p>
If, to maintain data abstraction and avoid including otherwise unnecessary
header files, you find that you want the type <b><tt>xxx_t</tt></b> to be
available in a header file that doesn't include the definition of the
structure <b><tt>xxx_s</tt></b>, use this approach:

<blockquote>
<b><tt>#ifndef xxx_DEFINED</tt></b><br>
<b><tt>#&nbsp;&nbsp;define xxx_DEFINED</tt></b><br>
<b><tt>typedef struct xxx_s xxx_t;</tt></b><br>
<b><tt>#endif</tt></b><br>
<b><tt>struct xxx_s {</tt></b><br>
&nbsp;&nbsp;&nbsp;... members ...<br>
<b><tt>};</tt></b>
</blockquote>

<p>
You can then copy the first 4 lines in other header files.  (Don't ever
include them in an executable code file.)

<p>
The Ghostscript memory manager requires run-time type information for every
structure.  (We don't document this here: see the <a
href="Develop.htm#Structure_descriptors">Structure descriptors</a> section
of the developer documentation for details.)  Putting the descriptor for a
structure next to the structure definition will help keep the two
consistent, so immediately after the definition of a structure
<b><tt>xxx_s</tt></b>, define its structure descriptor:

<blockquote>
<b><tt>struct xxx_s {</tt></b><br>
&nbsp;&nbsp;&nbsp;... members ...<br>
<b><tt>};</tt></b><br>
<b><tt>#define private_st_xxx()&nbsp;&nbsp;/* in </tt></b>&lt;filename&gt;<tt><b>.c */\</tt></b><br>
<b><tt>&nbsp;&nbsp;gs_private_st_</tt></b>&lt;whatever&gt;<b><tt>(st_xxx, xxx_t,\</tt></b><br>
<b><tt>&nbsp;&nbsp;&nbsp;&nbsp;"xxx_t", xxx_enum_ptrs, xxx_reloc_ptrs,\</tt></b><br>
<b><tt>&nbsp;&nbsp;&nbsp;&nbsp;</tt></b>... additional parameters as needed ...<b><tt>)</tt></b>
</blockquote>

<p>
The file that implements operations on this structure
(&lt;filename&gt;<b><tt>.c</tt></b>) should then include, near the
beginning, the line:

<blockquote>
<b><tt>private_st_xxx();</tt></b>
</blockquote>

<p>
In much existing code, structure descriptors are declared as
<b><tt>public</tt></b>, which allows clients to allocate instances of the
structure directly.  We now consider this bad design.  Instead, structure
descriptors should always be <b><tt>private</tt></b>; the implementation
file should provide one or more procedures for allocating instances, e.g.,

<blockquote>
<b><tt>xxx_t *gs_xxx_alloc(P1(gs_memory_t *mem));</tt></b>
</blockquote>

<p>
If it is necessary to make a structure descriptor public, it should be
declared in its clients as

<blockquote>
<b><tt>extern_st(st_xxx);</tt></b>
</blockquote>

<h3><a name="Standard_library"></a>Standard library features</h3>

<p>
Only use library features that are documented in the established ANSI
standard (e.g., Harbison & Steele's book).  Do not use procedures that are
"standards" promulgated by Microsoft (e.g., <b><tt>stricmp</tt></b>), or
originate in BSD Unix (e.g., <b><tt>strcasecmp</tt></b>), or were added in
later versions of the standard such as C 9X.

<h3><a name="Other"></a>Miscellany</h3>

<p>
The most important descriptive comments are ones in header files that
describe structures, including invariants; but every procedure or structure
declaration, or group of other declarations, should have a comment.  Don't
spend a lot of time commenting executable code unless something unusual or
subtle is going on.

<p>
In older code, calling a variable or parameter procedure always used
explicit indirection, for instance, <b><tt>(*ptr-&gt;func)(...)</tt></b>
rather than <b><tt>ptr-&gt;func(...)</tt></b>.  Since all current compilers
accept the latter form, use it in new code.

<p>
Don't write expressions that depend on order of evaluation, unless the order
is created explicitly by use of <b><tt>||</tt></b>,
<b><tt>&amp;&amp;</tt></b>, <b><tt>?:</tt></b>, <b><tt>,</tt></b>, or
function nesting (the arguments of a function must be evaluated before the
function is called).  In particular, don't assume that the arguments of a
function will be evaluated left-to-right, or that the left side of an
assignment will be evaluated before the right.

<p>
Don't bother using <b><tt>const</tt></b> for anything other than with
pointers as described above.  However, in those places where it is necessary
to cast a pointer of type <b><tt>const&nbsp;T&nbsp;*</tt></b> to type
<b><tt>T&nbsp;*</tt></b>, always include a comment that explains why you are
"breaking const".

<hr>

<h2><a name="File_structuring"></a>File structuring</h2>

<h3><a name="All_files"></a>All files</h3>

<p>
Keep file names within the "8.3" format for portability
(the "long file name" facilities of MS Windows are a hack that sometimes
doesn't work properly with code written by parties other than Microsoft):
<ul>
<li>Use only letters, digits, dash, and underscore in file names.
<li>Don't assume upper and lower case letters are distinct.
<li>Put no more than 8 characters before the ".", if any.
<li>If there is a ".", put between 1 and 3 characters after the ".".
</ul>

<p>
For files other than documentation files, use only lower case letters
in the names; for HTML documentation files, capitalize the first letter.

<p>
Every code file should start with comments containing

<ol>
<li>a copyright notice,
<li>the name of the file in the form of an RCS Id:

<blockquote><b><tt>
/*Id$: filename.ext $*/
</tt></b></blockquote>

<p>
(using the comment convention appropriate to the language of the file), and

<li>a summary, no more than one line, of what the file contains.
</ol>

<p>
If you create a file by copying the beginning of another file, be sure to
update the copyright year and change the file name.

<h3><a name="Makefiles"></a>Makefiles</h3>

<p>
Use the extension <b><tt>.mak</tt></b> for makefiles.

<p>
For each

<blockquote><b><tt>
#include "xxx.h"
</tt></b></blockquote>

<p>
make sure there is a dependency on <b><tt>$(xxx_h)</tt></b> in the
makefile.  If xxx ends with a "<b><tt>_</tt></b>", this rule still holds,
so that if you code

<blockquote><b><tt>
#include "math_.h"
</tt></b></blockquote>

<p>
the makefile must contain a dependency on "<b><tt>$(math__h)</tt></b>"
(note the two underscores "<b><tt>__</tt></b>").

<p>
List the dependencies bottom-to-top, like the <b><tt>#include</tt></b>
statements themselves; within each level, list them alphabetically.  Do
this also with <b><tt>#include</tt></b> statements themselves whenever
possible (but sometimes there are inter-header dependencies that require
bending this rule).

<p>
For compatibility with the build utilities on OpenVMS, always put a space
before the colon that separates the target(s) of a rule from the dependents.

<h3><a name="General_C_code"></a>General C code</h3>

<p>
List <b><tt>#include</tt></b> statements from "bottom" to "top", that is,
in the following order:

<blockquote><ol>
<li>System includes (<b><tt>"xxx_.h"</tt></b>)
<li><b><tt>gs*.h</tt></b>
<li><b><tt>gx*.h</tt></b> (yes, <b><tt>gs</tt></b> and <b><tt>gx</tt></b>
are in the wrong order.)
<li><b><tt>s*.h</tt></b>
<li><b><tt>i*.h</tt></b> (or other interpreter headers that don't start
with "<b><tt>i</tt></b>")
</ol></blockquote>

<h3><a name="Headers"></a>Headers (<b><tt>.h</tt></b> files)</h3>

<p>
In header files, always use the following at the beginning of a header file
to prevent double inclusion:

<blockquote>
{{ Copyright notice etc. }}<br><br>

<b><tt>#ifndef </tt></b>&lt;filename&gt;<b><tt>_INCLUDED</tt></b><br>
<b><tt>#define </tt></b>&lt;filename&gt;<b><tt>_INCLUDED</tt></b><br><br>

{{ The contents of the file }}<br><br>

<b><tt>#endif /* </tt></b>&lt;filename&gt;<b><tt>_INCLUDED */</tt></b>
</blockquote>

<p>
The header file is the first place that a reader goes for
information about procedures, structures, constants, etc., so ensure that
every procedure and structure has a comment that says what it does.  Divide
procedures into meaningful groups set off by some distinguished form of
comment.

<h3><a name="Source"></a>Source (<b><tt>.c</tt></b> files)</h3>

<p>
After the initial comments, arrange C files in the following order:

<blockquote><ol>
<li><b><tt>#include</tt></b> statements
<li>Exported data declarations
<li>Explicit externs (if necessary)
<li>Forward declarations of procedures
<li>Private data declarations
<li>Exported procedures
<li>Private procedures
</ol></blockquote>

<p>
Be flexible about the order of the declarations if necessary to improve
readability.  Many older files don't follow this order, often without good
reason.

<hr>

<h2><a name="Formatting"></a>Formatting</h2>

<h3><a name="Indentation"></a>Indentation</h3>

<p>
We've formatted all of our code using the GNU <b><tt>indent</tt></b> program.

<blockquote><b><tt>
indent&nbsp;-bad&nbsp;-nbap&nbsp;-nsob&nbsp;-br&nbsp;-ce&nbsp;-cli4&nbsp;-npcs&nbsp;-ncs&nbsp;\<br>
&nbsp;&nbsp;&nbsp;-i4&nbsp;-di0&nbsp;-psl&nbsp;-lp&nbsp;-lps&nbsp;somefile.c
</tt></b></blockquote>

<p>
does a 98% accurate job of producing our preferred style.  Unfortunately,
there are bugs in all versions of GNU <b><tt>indent</tt></b>, requiring
both pre- and post-processing of the code.  The <b><tt>gsindent</tt></b>
script in the Ghostscript fileset contains the necessary workarounds.

<p>
Put indentation points every 4 spaces, with 8 spaces = 1 tab stop.

<p>
For assignments (including chain assignments), put the entire statement on
one line if it will fit; if not, break it after a <b><tt>=</tt></b> and
indent all the following lines.  I.e., format like this:

<blockquote>
var1&nbsp;<b><tt>=</tt></b>&nbsp;value<b><tt>;</tt></b><br>
var1&nbsp;<b><tt>=</tt></b>&nbsp;var2&nbsp;<b><tt>=</tt></b>&nbsp;value<b><tt>;</tt></b><br>
var1&nbsp;<b><tt>=</tt></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;value<b><tt>;</tt></b><br>
var1&nbsp;<b><tt>=</tt></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;var2&nbsp;<b><tt>=</tt></b>&nbsp;value<b><tt>;</tt></b><br>
var1&nbsp;<b><tt>=</tt></b>&nbsp;var2&nbsp;<b><tt>=</tt></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;value<b><tt>;</tt></b>
</blockquote>

<p>
But not like this:

<blockquote>
var1&nbsp;<b><tt>=</tt></b><br>
var2&nbsp;<b><tt>=</tt></b> value<b><tt>;</tt></b>
</blockquote>

<p>
Indent in-line blocks thus:

<blockquote>
<b><tt>{</tt></b><br>
&nbsp;&nbsp;&nbsp;... declarations ...<br>
&nbsp;&nbsp;&nbsp;{{ blank line if any declarations above }}<br>
&nbsp;&nbsp;&nbsp;... statements ...<br>
<b><tt>}</tt></b>
</blockquote>

<p>
Similarly, indent procedures thus:

<blockquote>
return_type<br>
proc_name(... arguments ...)<br>
<b><tt>{</tt></b><br>
&nbsp;&nbsp;&nbsp;... declarations ...<br>
&nbsp;&nbsp;&nbsp;{{ blank line if any declarations above }}<br>
&nbsp;&nbsp;&nbsp;... statements ...<br>
<b><tt>}</tt></b>
</blockquote>

<p>
If a control construct (<b><tt>if</tt></b>, <b><tt>do</tt></b>,
<b><tt>while</tt></b>, or <b><tt>for</tt></b>) has a one-line body, use
this:

<blockquote>
... control construct ...<br>
&nbsp;&nbsp;&nbsp;... subordinate simple statement ...
</blockquote>

<p>
If it has a multi-line body, use this:

<blockquote>
... control construct ... <b><tt>{</tt></b><br>
&nbsp;&nbsp;&nbsp;... subordinate code ...<br>
<b><tt>}</tt></b>
</blockquote>

<p>
If the subordinate code has declarations, see blocks above.

<p>
For if-else statements, do this:

<blockquote>
<b><tt>if (</tt></b> ...<b><tt> ) {</tt></b><br>
&nbsp;&nbsp;&nbsp;... subordinate code ...<br>
<b><tt>} else if (</tt></b> ...<b><tt> ) {</tt></b><br>
&nbsp;&nbsp;&nbsp;... subordinate code ...<br>
<b><tt>} else {</tt></b><br>
&nbsp;&nbsp;&nbsp;... subordinate code ...<br>
<b><tt>}</tt></b>
</blockquote>

<p>
When there are more than two alternatives, as in the example above, use the
above ("parallel") syntax rather than the following ("nested") syntax:

<blockquote>
<b><tt>if (</tt></b> ...<b><tt> ) {</tt></b><br>
&nbsp;&nbsp;&nbsp;... subordinate code ...<br>
<b><tt>} else {</tt></b><br>
<b><tt>&nbsp;&nbsp;&nbsp;if (</tt></b> ...<b><tt> ) {</tt></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;... subordinate code ...<br>
<b><tt>&nbsp;&nbsp;&nbsp;} else {</tt></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;... subordinate code ...<br>
<b><tt>&nbsp;&nbsp;&nbsp;}</tt></b><br>
<b><tt>}</tt></b>
</blockquote>

<p>
Similarly, for do-while statements, do this:

<blockquote>
<b><tt>do {</tt></b><br>
&nbsp;&nbsp;&nbsp;... body ...<br>
<b><tt>} while (</tt></b> ... condition ... <b><tt>);</tt></b>
</blockquote>

<h3><a name="Spaces"></a>Spaces</h3>

<p>
Do put a space:
<ul>
<li>after every comma and semicolon, unless it ends a line;
<li>around every binary operator other than "<b><tt>-&gt;</tt></b>" and
"<b><tt>.</tt></b>", although you can omit the spaces around the innermost
operator in a nested expression if you like;
<li>on both sides of the parentheses of an <b><tt>if</tt></b>, <b><tt>for</tt></b>, or <b><tt>while</tt></b>.
</ul>

<p>
Don't put a space:
<ul>
<li>at the end of a line;
<li>before a comma or semicolon;
<li>after unary prefix operators;
<li>before the parenthesis of a macro or procedure call.
</ul>

<h3><a name="Parentheses"></a>Parentheses</h3>

<p>
Parentheses are important in only a few places:

<ul>
<li>Around the inner subexpressions in expressions that mix
<b><tt>&amp;&amp;</tt></b> and <b><tt>||</tt></b>, even if they are not
required by precedence, for example

<blockquote><b><tt>
(xx &amp;&amp; yy) || zz
</tt></b></blockquote>

<li>Similarly around inner subexpressions in expressions that mix
<b><tt>&amp;</tt></b>, <b><tt>|</tt></b>, or shifts, especially if mixing
these with other operators, for instance

<blockquote><b><tt>
(x &lt;&lt; 3) | (y &gt;&gt; 5)
</tt></b></blockquote>

<li>In macro definitions around every use of an argument that logically
could be an expression, for example

<blockquote><b><tt>
((x) * (x) + (y) * (y))
</tt></b></blockquote>

</ul>

<p>
Anywhere else, given the choice, use fewer parentheses.

<p>
For stylistic consistency with the existing Ghostscript code, put
parentheses around conditional expressions even if they aren't
syntactically required, unless you really dislike doing this.  Note that
the parentheses should go around the entire expression, not the condition.
For instance, instead of

<blockquote><b><tt>
hpgl_add_point_to_path(pgls, arccoord_x, arccoord_y,<br>
&nbsp;&nbsp;&nbsp;(pgls-&gt;g.pen_down) ? gs_lineto : gs_moveto);
</tt></b></blockquote>

<p>
use

<blockquote><b><tt>
hpgl_add_point_to_path(pgls, arccoord_x, arccoord_y,<br>
&nbsp;&nbsp;&nbsp;(pgls-&gt;g.pen_down ? gs_lineto : gs_moveto));
</tt></b></blockquote>

<hr>

<h2><a name="Naming"></a>Naming</h2>

<h3><a name="General_naming"></a>General rules</h3>

<p>
Use fully spelled-out English words in names, rather than contractions.
This is most important for procedure and macro names, global variables and
constants, values of <b><tt>#define</tt></b> and <b><tt>enum</tt></b>,
<b><tt>struct</tt></b> and other <b><tt>typedef</tt></b> names, and
structure member names, and for argument and variable names which have
uninformative types like <b><tt>int</tt></b>.  It's not very important for
arguments or local variables of distinctive types, or for local index or
count variables.

<p>
Avoid names that run English words together:
"<b><tt>hpgl_compute_arc_center</tt></b>" is better than
"<b><tt>hpgl_compute_arccenter</tt></b>".  However, for terms drawn from
some predefined source, like the names of PostScript operators, use a term
in its well-known form (for instance, <b><tt>gs_setlinewidth</tt></b>
rather than <b><tt>gs_set_line_width</tt></b>).

<p>
Procedures, variables, and structures visible outside a single
<b><tt>.c</tt></b> file should generally have prefixes that indicate what
subsystem they belong to (in the case of Ghostscript, <b><tt>gs_</tt></b>
or <b><tt>gx_</tt></b>).  This rule isn't followed very consistently.

<hr>

<h2><a name="Miscellany"></a>Miscellany</h2>

<h3><a name="Single_use_procedures"></a>Single-use procedures</h3>

<p>
In general, don't create procedures that are private and only called from
one place.  However, if a compound statement (especially an arm of a
conditional) is too long for the eye easily to match its enclosing braces
"<b><tt>{...}</tt></b>" -- that is, longer than 10 or 15 lines -- and it
doesn't use or set a lot of state held in outer local variables, it may be
more readable if you put it in a procedure.

<h3><a name="Local_variables"></a>Local variables</h3>

<p>
Don't assign new values to procedure parameters.  It makes debugging very
confusing when the parameter values printed for a procedure are not the
ones actually supplied by the caller.  Instead use a separate local
variable initialized to the value of the parameter.

<p>
If a local variable is only assigned a value once, assign it that value at
its declaration, if possible.  For example,

<blockquote>
<b><tt>int x = </tt></b>some expression <b><tt>;</tt></b>
</blockquote>

<p>
rather than

<blockquote>
<b><tt>int x;</tt></b><br>
...<br>
<b><tt>x = </tt></b> some expression <b><tt>;</tt></b>
</blockquote>

<p>
Use a local pointer variable like this to "narrow" pointer types:

<blockquote>
<b><tt>int</tt></b><br>
someproc(... <b><tt>gx_device *dev</tt></b> ...)<br>
<b><tt>{<br>
&nbsp;&nbsp;&nbsp;gx_device_printer *const pdev = (gx_device_printer *)dev;</tt></b><br>
&nbsp;&nbsp;&nbsp;...<br>
<b><tt>}</tt></b>
</blockquote>

<h3><a name="Compiler_warnings"></a>Compiler warnings</h3>

<p>
The following section refers to the warnings produced by <b><tt>gcc</tt></b>:
your compiler may produce different ones.

<p>
It's OK if compilation produces the following warnings:

<ul>
<li><b><tt>&lt;name&gt; might be used uninitialized in this function</tt></b>
<li><b><tt>cast discards `const' from pointer target type</tt></b>
</ul>

<p>
The first of these often occurs because the compiler isn't aware of control
flow restrictions that guarantee the variable will be initialized before
use: if it occurs in new code, check the code carefully, but don't worry
about the message.  The second is often unavoidable in code that initializes
or frees a structure that is otherwise <b><tt>const</tt></b> during its
lifetime.
<p>

Do work hard to eliminate all warnings other than these,
since they often indicate the possible presence of coding errors.
In particular, get rid of warnings about parameter passing or
initialization that discards <b><tt>const</tt></b>,
by using explicit casts.

<hr>

<h2><a name="Conventions"></a>Ghostscript conventions</h2>

<h3><a name="Specific_names"></a>Specific names</h3>

<p>
The Ghostscript code uses certain names consistently for certain kinds of
values.  Some of the commonest and least obvious are these two:

<h4><a name="code"></a><b><tt>code</tt></b></h4>

<blockquote>
A value to be returned from a procedure:

<table cellpadding=0 cellspacing=0>
<tr valign=top>	<td align=right>&lt; 0
	<td>&nbsp;&nbsp;&nbsp;&nbsp;
	<td>An error code defined in
<a href="../src/gserrors.h">gserrors.h</a>
(or <a href="../src/errors.h">errors.h</a>)
<tr valign=top>	<td align=right>0
	<td>&nbsp;
	<td>Normal return
<tr valign=top>	<td align=right>&gt; 0
	<td>&nbsp;
	<td>A non-standard but successful return (which must be documented, preferably with the procedure's prototype)
</table>

</blockquote>

<h4><a name="status"></a><b><tt>status</tt></b></h4>

<blockquote>
A value returned from a stream procedure:

<table cellpadding=0 cellspacing=0>
<tr valign=top>	<td align=right>&lt; 0
	<td>&nbsp;&nbsp;&nbsp;&nbsp;
	<td>An exceptional condition as defined in
<a href="../src/scommon.h">scommon.h</a>
<tr valign=top>	<td align=right>0
	<td>&nbsp;
	<td>Normal return (or, from the "<b><tt>process</tt></b>" procedure, means that more input is needed)
<tr valign=top>	<td align=right>1
	<td>&nbsp;
	<td>More output space is needed (from the "<b><tt>process</tt></b>" procedure)
</table>
</blockquote>

<h3><a name="Objects"></a>"Objects"</h3>

<p>
Ghostscript makes heavy use of object-oriented constructs, including
analogues of classes, instances, subclassing, and class-associated
procedures.  However, these constructs are implemented in C rather than C++,
for two reasons:

<ul>

<li>The first Ghostscript code was written in 1986, long before C++ was
codified or was well supported by tools.  Even today, C++ tools rarely
support C++ as well as C tools support C.

<li>C++ imposes its own implementations for virtual procedures, inheritance,
run-time type information, and (to some extent) memory management.
Ghostscript requires use of its own memory manager, and also sometimes
requires the ability to change the virtual procedures of an object
dynamically.

</ul>

<h4>Classes</h4>

<p>
The source code representation of a class is simply a
<b><tt>typedef</tt></b> for a C <b><tt>struct</tt></b>.  See <a
href="C-style.htm#Structures">Structures</a>, above, for details.

<h4>Procedures</h4>

<p>
Ghostscript has no special construct for non-virtual procedures associated
with a class.  In some cases, the <b><tt>typedef</tt></b> for the class is
in a header file but the <b><tt>struct</tt></b> declaration is in the
implementation code file: this provides an extra level of opaqueness, since
clients then can't see the representation and must make all accesses through
procedures.  You should use this approach in new code, if it doesn't
increase the size of the code too much or require procedure calls for very
heavily used accesses.

<p>
Ghostscript uses three different approaches for storing and accessing
virtual procedures, plus a fourth one that is recommended but not currently
used.  For exposition, we assume the class (type) is named
<b><tt>xxx_t</tt></b>, it has a virtual procedure
<b><tt>void&nbsp;(*virtu)(P1(xxx_t&nbsp;*))</tt></b>, and we have a variable
declared as <b><tt>xxx_t&nbsp;*pxx</tt></b>.

<ol>

<li>The procedures are stored in a separate, constant structure of type
<b><tt>xxx_procs</tt></b>, of which <b><tt>virtu</tt></b> is a member.  The
structure definition of <b><tt>xxx_t</tt></b> includes a member defined as
<b><tt>const&nbsp;xxx_procs&nbsp;*procs</tt></b> (always named
<b><tt>procs</tt></b>).  The construct for calling the virtual procedure is
<b><tt>pxx->procs->virtu(pxx)</tt></b>.

<li>The procedures are defined in a structure of type
<b><tt>xxx_procs</tt></b> as above.  The structure definition of
<b><tt>xxx_t</tt></b> includes a member defined as
<b><tt>xxx_procs&nbsp;procs</tt></b> (always named <b><tt>procs</tt></b>).
The construct for calling the virtual procedure is
<b><tt>pxx->procs.virtu(pxx)</tt></b>.

<li>The procedures are not defined in a separate structure: each procedure
is a separate member of <b><tt>xxx_t</tt></b>.  The construct for calling
the virtual procedure is <b><tt>pxx->virtu(pxx)</tt></b>.

<li>The procedures are defined in a structure of type
<b><tt>xxx_procs</tt></b> as above.  The structure definition of
<b><tt>xxx_t</tt></b> includes a member defined as
<b><tt>xxx_procs&nbsp;procs[1]</tt></b> (always named
<b><tt>procs</tt></b>).  The construct for calling the virtual procedure is
again <b><tt>pxx->procs->virtu(pxx)</tt></b>.

</ol>

<p>
Note that in approach 1, the procedures are in a shared constant structure;
in approaches 2 - 4, they are in a per-instance structure that can be
changed dynamically, which is sometimes important.

<p>
In the present Ghostscript code, approach 1 is most common, followed by 2
and 3; 4 is not used at all.  For new code, you should use 1 or 4: that way,
all virtual procedure calls have the same form, regardless of whether the
procedures are shared and constant or per-instance and mutable.

<h4>Subclassing</h4>

<p>
Ghostscript's class mechanism allows for subclasses that can add data
members, or can add procedure members if approach 1 or 3 (above) is used.
Since C doesn't support subclassing, we use a convention to accomplish it.
In the example below, <b><tt>gx_device</tt></b> is the root class; it has a
subclass <b><tt>gx_device_forward</tt></b>, which in turn has a subclass
<b><tt>gx_device_null</tt></b>.  First we define a macro for all the members
of the root class, and the root class type.  (As for structures in general,
classes need a structure descriptor, as discussed in <a
href="#Structures">Structures</a> above: we include these in the examples
below.)

<blockquote><b><tt>
#define gx_device_common\<br>
&nbsp;&nbsp;&nbsp;&nbsp;type1 member1;\<br>
&nbsp;&nbsp;&nbsp;&nbsp;</tt></b>...<b><tt><br>
&nbsp;&nbsp;&nbsp;&nbsp;typeN memberN<br>
<br>
typedef struct gx_device_s {<br>
&nbsp;&nbsp;&nbsp;&nbsp;gx_device_common;<br>
} gx_device;<br>
<br>
#define private_st_gx_device()&nbsp;&nbsp;/* in gsdevice.c */\<br>
&nbsp;&nbsp;gs_private_st_</tt></b>&lt;whatever&gt;<b><tt>(st_gx_device, gx_device,\<br>
&nbsp;&nbsp;&nbsp;&nbsp;"gx_device", device_enum_ptrs, device_reloc_ptrs,\<br>
&nbsp;&nbsp;&nbsp;&nbsp;</tt></b>... additional parameters as needed ...<b><tt>)</tt></b>
</tt></b></blockquote>

<p>
We then define a similar macro and type for the subclass.

<blockquote><b><tt>
#define gx_device_forward_common\<br>
&nbsp;&nbsp;&nbsp;&nbsp;gx_device_common;\<br>
&nbsp;&nbsp;&nbsp;&nbsp;gx_device *target<br>
<br>
typedef struct gx_device_forward_s {<br>
&nbsp;&nbsp;&nbsp;&nbsp;gx_device_forward_common;<br>
} gx_device_forward;<br>
<br>
#define private_st_device_forward()&nbsp;&nbsp;/* in gsdevice.c */\<br>
&nbsp;&nbsp;gs_private_st_suffix_add1(st_device_forward, gx_device_forward,\<br>
&nbsp;&nbsp;&nbsp;&nbsp;"gx_device_forward", device_forward_enum_ptrs, device_forward_reloc_ptrs,\<br>
&nbsp;&nbsp;&nbsp;&nbsp;gx_device, target)
</tt></b></blockquote>

<p>
Finally, we define a leaf class, which doesn't need a macro because we don't
currently subclass it.  (We can create the macro later if needed, with no
changes anywhere else.)  In this particular case, the leaf class has no
additional data members, but it could have some.

<blockquote><b><tt>
typedef struct gx_device_null_s {<br>
&nbsp;&nbsp;&nbsp;&nbsp;gx_device_forward_common;<br>
};<br>
<br>
#define private_st_device_null()&nbsp;&nbsp;/* in gsdevice.c */\<br>
&nbsp;&nbsp;gs_private_st_suffix_add0_local(st_device_null, gx_device_null,\<br>
&nbsp;&nbsp;&nbsp;&nbsp;"gx_device_null", device_null_enum_ptrs, device_null_reloc_ptrs,\<br>
&nbsp;&nbsp;&nbsp;&nbsp;gx_device_forward)
</tt></b></blockquote>

<p>
Note that the above example is <strong>not</strong> the actual definition of
the <b><tt>gx_device</tt></b> structure type: the actual type has some
additional complications because it has a finalization procedure.  See <a
href="../src/gxdevcli.h">src/gxdevcli.h</a> for the details.

<p>
If you add members to a root class (such as <b><tt>gx_device</tt></b> in
this example), or change existing members, do this in the
<b><tt>gx_device_common</tt></b> macro, not the <b><tt>gx_device</tt></b>
structure definition.  Similarly, to change the
<b><tt>gx_device_forward</tt></b> class, modify the
<b><tt>gx_device_forward_common</tt></b> macro, not the structure
definition.  Only change the structure definition if the class is a leaf
class (one with no <b><tt>_common</tt></b> macro and no possibility of
subclassing), like <b><tt>gx_device_null</tt></b>.

<h3><a name="Error_handling"></a>Error handling</h3>

<p>
Every caller should check for error returns and, in general, propagate them
to <b>its</b> callers.  By convention, nearly every procedure returns an
<b><tt>int</tt></b> to indicate the outcome of the call:

<blockquote><table cellpadding=0 cellspacing=0>
<tr valign=top>	<td align=right>&lt; 0
	<td>&nbsp;&nbsp;&nbsp;&nbsp;
	<td>Error return
<tr valign=top>	<td align=right>0
	<td>&nbsp;
	<td>Normal return
<tr valign=top>	<td align=right>&gt; 0
	<td>&nbsp;
	<td>Non-error return other than the normal case
</table></blockquote>

<p>
To make a procedure generate an error and return it, as opposed to
propagating an error generated by a lower procedure, you should use

<blockquote>
<b><tt>return_error(</tt></b><em>error_number</em><b><tt>);</tt></b>
</blockquote>

<p>
Sometimes it is more convenient to generate the error in one place and
return it in another.  In this case, you should use

<blockquote>
<b><tt>code = gs_note_error(</tt></b><em>error_number</em><b><tt>);</tt></b><br>
...<br>
<b><tt>return code;</tt></b>
</blockquote>

<p>
In executables built for debugging, the <b><tt>-E</tt></b> (or
<b><tt>-Z#</tt></b>) command line switch causes <b><tt>return_error</tt></b>
and <b><tt>gs_note_error</tt></b> to print the error number and the source
file and line: this is often helpful for identifying the original cause of
an error.

<p>
See the file <a href="../src/gserrors.h">src/gserrors.h</a> for the error
return codes used by the graphics library, most of which correspond directly
to PostScript error conditions.

<!-- [2.0 end contents] ==================================================== -->

<!-- [3.0 begin visible trailer] =========================================== -->
<hr>

<p>
<small>Copyright &copy; 1996, 1997, 1998 Aladdin Enterprises.
All rights reserved.</small>

<p>
<small>This file is part of AFPL Ghostscript.  See the <a
href="Public.htm">Aladdin Free Public License</a> (the "License") for full
details of the terms of using, copying, modifying, and redistributing AFPL
Ghostscript.</small>

<p>
<small>Ghostscript version 6.60, 31 December 2000

<!-- [3.0 end visible trailer] ============================================= -->

</body>
</html>
