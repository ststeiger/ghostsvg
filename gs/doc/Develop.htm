<html>
<head>
<title>Information for Ghostscript developers</title>
<!-- $Id$ -->
</head>

<body>
<!-- [1.0 begin visible header] ============================================ -->

<!-- [1.1 begin headline] ================================================== -->

<table width="100%" border="0">
<tr><th align="center" bgcolor="#CCCC00"><font size=6>
Information for Ghostscript developers
</font>
</table>

<!-- [1.1 end headline] ==================================================== -->

<!-- [1.2 begin table of contents] ========================================= -->

<h2>Table of contents</h2>

<blockquote><ul>
<li><a href="#Introduction">Introduction</a>
<li><a href="#File_roadmap">File roadmap</a>
<ul>
<li><a href="#Layer_architecture">Layer architecture</a>
<li><a href="#Plumbing">Plumbing</a>
<li><a href="#Graphics_library">Graphics library</a>
<ul>
<li><a href="#Graphics_library_support">Support</a>,
    <a href="#Graphics_model">Graphics model</a>,
    <a href="#Driver_support">Driver support</a>,
    <a href="#Graphics_library_miscellaneous">Miscellaneous</a>
</ul>
<li><a href="#PostScript_interpreter">PostScript interpreter</a>
<ul>
<li><a href="#PostScript_interpreter_support">Support</a>,
    <a href="#Scanning_parsing">Scanning/parsing</a>,
    <a href="#Standard_operators">Standard operators</a>,
    <a href="#Non_standard_operators">Non-standard operators</a>,
    <a href="#PostScript_code">PostScript code</a>
</ul>
<li><a href="#PDF_interpreter">PDF interpreter</a>
<li><a href="#Build_support">Build support</a>
<li><a href="#Utilities_in_PostScript">Utilities (in PostScript)</a>
</ul>
<li><a href="#Memory_management">Memory management</a>
<ul>
<li><a href="#Memory_manager_architecture">Memory manager architecture</a>
<ul>
<li><a href="#Objects_vs_strings">Objects vs strings</a>,
    <a href="#Structure_descriptors">Structure descriptors</a>,
    <a href="#Garbage_collection">Garbage collection</a>,
    <a href="#Movability">Movability</a>,
    <a href="#Stable_allocators">Stable_allocators</a>,
    <a href="#Parent_hierarchy">Parent hierarchy</a>,
    <a href="#Allocator_API">Allocator API</a>,
</ul>
<li><a href="#Freeing_storage">Freeing storage</a>
<ul>
<li><a href="#Explicit_freeing">Explicit freeing</a>,
    <a href="#Reference_counting">Reference counting</a>,
    <a href="#Real_garbage_collection">(Real) garbage collection</a>
</ul>
<li><a href="#Special_implementations">Special implementations</a>
<ul>
<li><a href="#malloc">malloc</a>,
    <a href="#Locking">Locking</a>,
    <a href="#Retrying">Retrying</a>
</ul>
<li><a href="#Standard_implementation">Standard implementation</a>
<li><a href="#PostScript_interpreter_extensions">PostScript interpreter extensions</a>
<ul>
<li><a href="#Refs_and_ref_objects">Refs and ref objects</a>,
    <a href="#save_forgetsave_restore">save/.forgetsave/restore</a>,
    <a href="#Interpreter_GC">Garbage collection</a>
</ul>
</ul>
<li><a href="#Portability">Portability</a>
<ul>
<li><a href="#Structural">Structural</a>
<ul>
<li><a href="#CPU_and_compiler">CPU and compiler</a>,
    <a href="#Library_headers">Library headers</a>,
    <a href="#Cross_platform_APIs">Cross-platform APIs</a>,
    <a href="#Makefiles">Makefiles</a>
</ul>
<li><a href="#Coding">Coding</a>
<ul>
<li><a href="#Explicit_dependencies">Explicit dependencies</a>,
    <a href="#Implicit_dependencies">Implicit dependencies</a>
</ul>
</ul>
<li><a href="#Adding_features_and_options">Adding features and options</a>
</ul></blockquote>

<!-- [1.2 end table of contents] =========================================== -->

<!-- [1.3 begin hint] ====================================================== -->

<p>For other information, see the <a href="Readme.htm">Ghostscript
overview</a> and the documentation related to <a
href="Maintain.htm">maintaining Ghostscript</a>.

<!-- [1.3 end hint] ======================================================== -->

<hr>

<!-- [1.0 end visible header] ============================================== -->

<!-- [2.0 begin contents] ================================================== -->

<h1><a name="Introduction"></a>Introduction</h1>

<p>
This document provides a wealth of information about Ghostscript's
internals, primarily for developers actively working on Ghostscript.

<p>
THIS FILE IS MOSTLY A SKELETON.  IT WILL BE A WORK IN PROGRESS THROUGH THE
END OF 2000.

<hr>

<h1><a name="File_roadmap"></a>File roadmap</h1>

<p>
This section of the document provides a roadmap to all of the Ghostscript
source files.

<h2><a name="Layer_architecture"></a>Layer architecture</h2>

<h2><a name="Plumbing"></a>Plumbing</h2>

<p>
Memory manager

<p>
Stream package
	Framework, files, strings
	Filters

<p>
Platform-specific code

<p>
Miscellaneous

<h2><a name="Graphics_library"></a>Graphics library</h2>

<h3><a name="Graphics_library_support"></a>Support</h3>

<h3><a name="Graphics_model"></a>Graphics model</h3>

<p>
Coordinate transformation

<p>
Path building + rendering

<p>
Clipping

<p>
Color spaces + color mapping

<p>
Halftoning

<p>
Character rendering + font cache

<p>
Images

<h3><a name="Driver_support"></a>Driver support</h3>

<p>
Low-level driver support

<p>
High-level driver support

<p>
Banding

<p>
Built-in devices

<h3><a name="Graphics_library_miscellaneous"></a>Miscellaneous</h3>

<h2><a name="PostScript_interpreter"></a>PostScript interpreter</h2>

<h3><a name="PostScript_interpreter_support"></a>Support</h3>

<p>
Memory management (refs, GC, save/restore)

<p>
Data structures (stacks, names, dicts, contexts)

<p>
Files/streams

<p>
Miscellaneous

<h3><a name="Scanning_parsing"></a>Scanning/parsing</h3>

<h3><a name="Standard operators"></a>Standard operators</h3>

<h3><a name="Non-standard operators"></a>Non-standard operators</h3>

<h3><a name="PostScript_code"></a>PostScript code</h3>

<p>
Resources

<p>
setpagedevice

<p>
Font loading

<p>
Encodings

<p>
Miscellaneous

<h2><a name="PDF_interpreter"></a>PDF interpreter</h2>

<h2><a name="Build_support"></a>Build support</h2>

<h2><a name="Utilities_in_PostScript"></a>Utilities (in PostScript)</h2>

<hr>

<h1><a name="Memory_management"></a>Memory management</h1>

<h2><a name="Memory_manager_architecture"></a>Memory manager architecture</h2>

<p>
In many environments, the memory manager is a set of library facilities that
implicitly manage the entire address space in a homogenous manner.
Ghostscript's memory manager architecture has none of these properties:

<ul>

<li>Rather than a single library accessed as procedures, Ghostscript
includes multiple allocator types, each of which in turn may have multiple
instances (allocators).  Allocators are 'objects' with a substantial set of
virtual functions.

<li>Rather than managing the entire address space, each allocator manages a
storage pool, which it may or may not be able to expand or reduce by calling
on a 'parent' allocator.

<li>Rather than a single genus of untyped storage blocks, Ghostscript's
allocators provide two genera -- type-tagged 'objects', and 'strings' --
with substantially different properties.

</ul>

<h3><a name="Objects_vs_strings"></a>Objects vs strings</h3>

<p>
As noted above, allocators provide two different storage genera.

<p>
Objects:

<ul>
<li>Are aligned in storage to satisfy the most stringent alignment
requirement imposed by the CPU or compiler;
<li>Can be referenced only by pointers to their start, not to any internal
location, unless special arrangements are made (see <a
href="Movability_and_GC">below</a>);
<li>May contain pointers to other objects, or to strings;
<li>Have an associated <em>structure descriptor</em> that specifies their
size (usually) and the location of any pointers contained within them.
</ul>

<p>
Given a pointer to an object, the allocator that allocated it must be able
to return the object's size and the pointer to its structure descriptor.
(It is up to the client to know what allocator allocated an object.)

<p>
Strings:

<ul>
<li>Are not aligned in storage;
<li>Can be referenced by pointers (consisting of a starting address and a
length) to any substring, starting anywhere within the string;
<li>May not contain pointers;
<li>Do not have a structure descriptor.
</ul>

<p>
The object/string distinction reflects a space/capability tradeoff.  The
per-object space overhead of the standard type of allocator is typically 12
bytes; this is too much to impose on every string of a few bytes.  On the
other hand, restricting object pointers to reference the start of the object
currently makes object garbage collection and compaction more
space-efficient.  If we were to redesign the standard allocator, we would
probably opt for a different design in which strings were allocated within
container objects of a few hundred bytes, and pointers into the middle of
all objects were allowed.

<h3><a name="Structure_descriptors"></a>Structure descriptors</h3>

<p>
Every object has an associated structure descriptor, which the caller
provides when allocating the object.  The structure descriptor serves
several purposes:

<ul>
<li>Specifying the size of the object for allocation;
<li>Providing pointer-enumeration and pointer-relocation procedures for
the garbage collector;
<li>Providing an optional finalization procedure to be called when the
object is freed (either explicitly or automatically).
</ul>

<p>
Structure descriptors are read-only, and are normally allocated statically
using one of a large set of macros.

<p>
While the structure descriptor normally specifies the size of the object,
one can also allocate an array of bytes or objects, whose size is a multiple
of the size in the descriptor.  For this reason, every object stores its
size as well as a reference to its descriptor.

<p>
Because the standard Ghostscript garbage collector is conservative and can
move objects, every object must have an accurate structure descriptor.  If
you define a new type of object (structure) that will be allocated in
storage managed by Ghostscript, you <em>must</em> create an accurate
descriptor for it, and use that descriptor to allocate it.  The process of
creating accurate descriptors for all structures was long and painful, and
accounted for many hard-to-diagnose bugs.

<p>
Files:
<a href="../src/gsstruct.h">src/gsstruct.h</a>,
<a href="../src/gsstype.h">src/gsstype.h</a>.

<h3><a name="Garbage_collection"></a>Garbage collection</h3>

<p>
The allocator architecture is designed to support compacting garbage
collection.  Every object must be able to enumerate all the pointers it
contains, both for tracing and for relocation.  As noted just above, the
structure descriptor provides procedures that do this.

<p>
Whether or not a particular allocator type actually provides a garbage
collector is up to the allocator: garbage collection is invoked through a
virtual procedure.  In practice, however, there are only two useful garbage
collectors for Ghostscript's own allocator:

<ul>
<li>The "real" garbage collector associated withthe PostScript interpreter,
described <a href="#Interpreter_GC">below</a>;
<li>A "non" garbage collector that only merges adjacent free blocks.
</ul>

<p>
Files:
<a href="../src/gsgc.h">src/gsgc.h</a>,
<a href="../src/gsnogc.c">src/gsnogc.c</a>,
<a href="../src/gsnogc.h">src/gsnogc.h</a>.

<h3><a name="Movability"></a>Movability</h3>

<p>
As just noted, objects are normally movable by the garbage collector.
However, some objects must be immovable, usually because some other piece of
software must retain pointers to them.  The allocator API includes
procedures for allocating both movable (default) and immovable objects.
Note, however, that even immovable objects must be traceable (have a
structure descriptor), and may be freed, by the garbage collector.

<h3><a name="Stable_allocators"></a>Stable allocators</h3>

<p>
Even though <b><tt>save</tt></b> and <b><tt>restore</tt></b> are concepts
from the PostScript interpreter, the allocator architecture includes a
feature to support them, called <em>stable</em> allocators, which are
described in detail <a href="#save_forgetsave_restore">below</a>.

<h3><a name="Parent_hierarchy">Parent hierarchy</h3>

<p>
When an allocator needs to add memory to the pool that it manages, it
requests the memory from its <em>parent</em> allocator.  Every allocator has
a pointer to its parent; multiple allocators may share a single parent.  The
ultimate ancestor of all allocators that can expand their pool dynamically
is an allocator that calls <b><tt>malloc</tt></b>, described <a
href="#malloc">below</a>.  However, especially in embedded environments, an
allocator may be limited to a fixed-size pool assigned to it when it is
created.

<h3><a name="Allocator_API"></a>Allocator API</h3>

In summary, the allocator API provides the following principal operations:

<ul>
<li>Allocate and free movable (default) or immovable objects and strings.
<li>Return the structure type and size of an object.
<li>Resize (shrink or grow) movable objects and strings, preserving
the contents insofar as possible.
<li>Report the size of the managed pool, and how much of it is in use.
<li>Register and unregister root pointers for the garbage collector.
<li>Free the allocator itself.
<li>Consolidate adjacent free blocks to reduce fragmentation.
</ul>

<p>
For details, see <a href="../src/gsmemory.h">src/gsmemory.h</a>.

<p>
Files:
<a href="../src/gsmemraw.h">src/gsmemraw.h</a>,
<a href="../src/gsmemory.h">src/gsmemory.h</a>,
<a href="../src/gsstruct.h">src/gsstruct.h</a>,
<a href="../src/gsstype.h">src/gsstype.h</a>.

<h2><a name="Freeing_storage"></a>Freeing storage</h2>

<p>
Ghostscript's memory management architecture provides three different ways
to free objects: explicitly, by reference counting, or by garbage
collection.  They provide different safety / performance / convenience
tradeoffs; we believe that all three are necessary.

<p>
Objects are always freed as a whole; strings may be freed piecemeal.

<p>
An object may have an associated finalization procedure, defined in the
structure descriptor.  This procedure is called just before the object is
freed, independent of which method is being used to free the object.  A few
types of objects have a virtual finalization procedure as well: the
finalization procedure defined in the descriptor simply calls the one in the
object.

<h3><a name="Explicit_freeing"></a>Explicit freeing</h3>

<p>
Objects and strings may be freed explicitly, using the
<b><tt>gs_free_</tt></b> virtual procedures in the allocator API.  It is up
to the client to ensure that all allocated objects are freed at most once,
and that there are no dangling pointers.

<p>
Explicit freeing is the fastest method, but is the least convenient and
least safe.  It is most appropriate when storage is freed in the same
procedure where it is allocated, or for storage that is known to be
referenced by only one pointer.

<h3><a name="Reference_counting"></a>Reference counting</h3>

<p>
Objects may be managed by reference counting.  When an object is allocated,
its reference count may be set to 0 or 1.  Subsequently, when the reference
count is decremented to 0, the object is freed.  Reference-counted objects
always have a virtual finalization procedure.

<p>
Reference counting is as fast as explicit freeing, but takes more space in
the object.  It is most appropriate for relatively large objects which are
referenced only from a small set of pointers.  Note that reference counting
cannot free objects that are involved in a pointer cycle (e.g., A -> B -> C
-> A).

<p>
Files:
<a href="../src/gsrefct.h">src/gsrefct.h</a>.

<h3><a name="Real_garbage_collection"></a>(Real) garbage collection</h3>

<p>
Objects and strings may be freed automatically by a garbage collector.  We
discuss this in detail <a href="#Interpreter_GC">below</a>.

<h2><a name="Special_implementations"></a>Special implementations</h2>

<h3><a name="malloc"></a>malloc</h3>

<p>
As mentioned <a href="Parent_hierarchy">above</a>, the ultimate ancestor of
all allocators with an expandable pool is one that calls
<b><tt>malloc</tt></b>.

<p>
Files:
<a href="../src/gsmalloc.h">src/gsmalloc.h</a>,
<a href="../src/gsmalloc.c">src/gsmalloc.c</a>.

<h3><a name="Locking"></a>Locking</h3>

<p>
In a multi-threaded environment, if an allocator must be callable from
multiple threads (for example, if it is used to allocate structures in one
thread that are passed to, and freed by, another thread), the allocator must
provide mutex protection.  Ghostscript provides this capability in the form
of a <em>wrapper</em> allocator, that simply forwards all calls to a
<em>target</em> allocator under protection of a mutex.  Using the wrapper
technique, any allocator can be made thread-safe.

<p>
Files:
<a href="../src/gsmemlok.h">src/gsmemlok.h</a>,
<a href="../src/gsmemlok.c">src/gsmemlok.c</a>.

<h3><a name="Retrying"></a>Retrying</h3>

<p>
In an embedded environment, job failure due to memory exhaustion is very
undesirable.  Ghostscript provides a wrapper allocator that, when an
allocation attempt fails, calls a client-provided procedure that can attempt
to free memory, then ask for the original allocation to be retried.  For
example, such a procedure can wait for a queue to empty, or can free memory
occupied by caches.

<p>
Files:
<a href="../src/gsmemret.h">src/gsmemret.h</a>,
<a href="../src/gsmemret.c">src/gsmemret.c</a>.

<h2><a name="Standard_implementation"></a>Standard implementation</h2>

<p>
The standard Ghostscript allocator gets storage from its parent (normally
the <b><tt>malloc</tt></b> allocator) in large blocks called
<em>chunks</em>, and then allocates objects up from the low end and strings
down from the high end.  Large objects or strings are allocated in their own
chunk.

<p>
The standard allocator maintains a set of free-block lists for small object
sizes, one list per size (rounded up to the word size), plus a free-block
list for large objects (but not for objects so large that they get their own
chunk: when such an object is freed, its chunk is returned to the parent).
The lists are not sorted; adjacent blocks are only merged if needed.

<p>
Files:
<a href="../src/gsalloc.c">src/gsalloc.c</a>,
<a href="../src/gsalloc.h">src/gsalloc.h</a>,
<a href="../src/gxalloc.h">src/gxalloc.h</a>,
<a href="../src/gxobj.h">src/gxobj.h</a>.

<h2><a name="PostScript_interpreter_extensions"></a>PostScript interpreter extensions</h2>

<p>
The PostScript interpreter uses an allocator that extends the graphic
library's standard allocator to handle PostScript objects,
<b><tt>save</tt></b> and <b><tt>restore</tt></b>, and real garbage
collection.

<p>
Files:
<a href="../src/ialloc.c">src/ialloc.c</a>,
<a href="../src/ialloc.h">src/ialloc.h</a>,
<a href="../src/imemory.h">src/imemory.h</a>.

<h3><a name="Refs_and_ref_objects"></a>Refs and ref objects</h3>

<p>
Files:
<a href="../src/iref.h">src/iref.h</a>,
<a href="../src/ivmspace.h">src/ivmspace.h</a>.

<h3><a name="save_forgetsave_restore"></a>save/.forgetsave/restore</h3>

<p>
Stable allocators + when to use them

<p>
Files:
<a href="../src/idosave.h">src/idosave.h</a>,
<a href="../src/isave.c">src/isave.c</a>,
<a href="../src/isave.h">src/isave.h</a>.

<h3><a name="Interpreter_GC"></a>Garbage collection</h3>

<p>
Files:
<a href="../src/igc.c">src/igc.c</a>,
<a href="../src/igc.h">src/igc.h</a>,
<a href="../src/igcref.c">src/igcref.c</a>,
<a href="../src/igcstr.c">src/igcstr.c</a>,
<a href="../src/igcstr.h">src/igcstr.h</a>.

<hr>

<h1><a name="Portability"></a>Portability</h1>

<p>
One of Ghostscript's most important features is its great portability across
platforms (CPUs, operating systems, compilers, and build tools).  The code
supports portability through two mechanisms:

<ul>

<li><a href="#Structural">Structural mechanisms</a> -- segregating
platform-dependent information into files in a particular way.

<li><a href="#Coding">Coding standards</a> -- avoiding relying on byte
order, scalar size, and platform-specific compiler or library features.

</ul>

<h2><a name="Structural"></a>Structural</h2>

<h3><a name="CPU_and_compiler"></a>CPU and compiler</h3>

<p>
Ghostscript attempts to discover characteristics of the CPU and compiler
automatically during the build process, by compiling and then executing a
program called <b><tt>genarch</tt></b>.  <b><tt>genarch</tt></b> generates a
file <b><tt>obj/arch.h</tt></b>, which almost all Ghostscript files then
include.  This works well for things like word size, byte order, and
floating point representation, but it can't determine whether or not a
compiler supports a particular feature, because if a feature is absent, the
compilation may fail.

<p>
Files:
<a href="../src/genarch.c">src/genarch.c</a>,
<a href="../obj/arch.h">obj/arch.h</a>.

<h3><a name="Library_headers"></a>Library headers</h3>

<p>
Despite the supposed standardization of ANSI C, platforms vary considerably
in where (and whether) they provide various standard library facilities.
Currently, Ghostscript's build process doesn't attempt to sort this out
automatically.  Instead, for each library header file
<b><tt>&lt;</tt></b><em>xxx</em><b><tt>.h&gt;</tt></b> there is a
corresponding Ghostscript source file
<b><tt>src/</tt></b><em>xxx</em><b><tt>_.h</tt></b>, containing a set of
compile-time conditionals that attempt to select the correct platform header
file, or in some cases substitute Ghostscript's own code for a missing
facility.  You may need to edit these files when moving to platforms with
unusually non-standard libraries.

<p>
Files:
<a href="../src/close_.h">src/close_.h</a>,
<a href="../src/ctype_.h">src/ctype_.h</a>,
<a href="../src/dirent_.h">src/dirent_.h</a>,
<a href="../src/dos_.h">src/dos_.h</a>,
<a href="../src/errno_.h">src/errno_.h</a>,
<a href="../src/fcntl_.h">src/fcntl_.h</a>,
<a href="../src/jerror_.h">src/jerror_.h</a>,
<a href="../src/malloc_.h">src/malloc_.h</a>,
<a href="../src/math_.h">src/math_.h</a>,
<a href="../src/memory_.h">src/memory_.h</a>,
<a href="../src/pipe_.h">src/pipe_.h</a>,
<a href="../src/png_.h">src/png_.h</a>,
<a href="../src/stat_.h">src/stat_.h</a>,
<a href="../src/stdio_.h">src/stdio_.h</a>,
<a href="../src/string_.h">src/string_.h</a>,
<a href="../src/time_.h">src/time_.h</a>,
<a href="../src/vmsmath.h">src/vmsmath.h</a>,
<a href="../src/windows_.h">src/windows_.h</a>,
<a href="../src/x_.h">src/x_.h</a>.

<p>
It has been suggested that the GNU 'configure' scripts do the above better,
for Unix systems, than Ghostscript's current methods.  While this may be
true, we have found configure scripts difficult to write, understand, and
maintain; and the 'autoconf' tool for generating configure scripts, which we
found easy to use, covers very little of the ground that Ghostscript
requires.

<h3><a name="Cross_platform_APIs"></a>Cross-platform APIs</h3>

<p>
For a few library facilities that are available on all platforms but are not
well standardized, or that may need to be changed for special environments,
Ghostscript defines its own APIs.  It is an architectural property of
Ghostscript that the implementations of these APIs are the only .c files
that are linked into an executable depending on the platform (as opposed to
depending on choices of drivers or optional features).

<p>
API files:
<a href="../src/gp.h">src/gp.h</a>,
<a href="../src/gpcheck.h">src/gpcheck.h</a>,
<a href="../src/gpgetenv.h">src/gpgetenv.h</a>,
<a href="../src/gpmisc.h">src/gpmisc.h</a>,
<a href="../src/gpsync.h">src/gpsync.h</a>.

<p>
Implementation files shared among multiple platforms:
<a href="../src/gp_getnv.c">src/gp_getnv.c</a>,
<a href="../src/gp_mktmp.c">src/gp_mktmp.c</a>,
<a href="../src/gp_nsync.c">src/gp_nsync.c</a>,
<a href="../src/gp_psync.c">src/gp_psync.c</a>,
<a href="../src/gp_strdl.c">src/gp_strdl.c</a>.

<p>
Platform-specific implementation files:
<a href="../src/gp_dosfe.c">src/gp_dosfe.c</a>,
<a href="../src/gp_dosfs.c">src/gp_dosfs.c</a>,
<a href="../src/gp_dvx.c">src/gp_dvx.c</a>,
<a href="../src/gp_iwatc.c">src/gp_iwatc.c</a>,
<a href="../src/gp_msdos.c">src/gp_msdos.c</a>,
<a href="../src/gp_mshdl.c">src/gp_mshdl.c</a>,
<a href="../src/gp_msio.c">src/gp_msio.c</a>,
<a href="../src/gp_mslib.c">src/gp_mslib.c</a>,
<a href="../src/gp_mswin.c">src/gp_mswin.c</a>,
<a href="../src/gp_mswin.h">src/gp_mswin.h</a>,
<a href="../src/gp_ntfs.c">src/gp_ntfs.c</a>,
<a href="../src/gp_os2.c">src/gp_os2.c</a>,
<a href="../src/gp_os9.c">src/gp_os9.c</a>,
<a href="../src/gp_sysv.c">src/gp_sysv.c</a>,
<a href="../src/gp_unifn.c">src/gp_unifn.c</a>,
<a href="../src/gp_unifs.c">src/gp_unifs.c</a>,
<a href="../src/gp_unix.c">src/gp_unix.c</a>,
<a href="../src/gp_vms.c">src/gp_vms.c</a>,
<a href="../src/gp_wgetv.c">src/gp_wgetv.c</a>,
<a href="../src/gp_win32.c">src/gp_win32.c</a>,
<a href="../src/gp_wsync.c">src/gp_wsync.c</a>.

<h3><a name="Makefiles"></a>Makefiles</h3>

<p>
Ghostscript's makefiles are structured very similarly to the cross-platform
library files.  The great majority of the makefiles are portable across all
platforms and all versions of <b><tt>make</tt></b>.  To achieve this, the
platform-independent makefiles must obey two constraints beyond those of the
POSIX <b><tt>make</tt></b> program:

<ul>

<li>No conditionals or <b><tt>include</tt></b>s are allowed.  While most
<b><tt>make</tt></b> programs now provide some form of conditional execution
and some form of inclusion, there is no agreement on the syntax.
(Conditionals and includes are allowed in platform-dependent makefiles; in
fact, an inclusion facility is required.)

<li>There must be a space on both sides of the : that separates the target
of a rule from its dependencies.  This is required for compatibility with
the OpenVMS <b><tt>MMS</tt></b> and <b><tt>MMK</tt></b> programs.

</ul>

<p>
The top-level makefile for each platform (where "platform" includes the OS,
the compiler, and the flavor of <b><tt>make</tt></b>) contains all the build
options, plus <b><tt>include</tt></b>s for the generic makefiles and any
platform-dependent makefiles that are shared among multiple platforms.

<p>
While most of the top-level makefiles build a PostScript and/or PDF
interpreter configuration, there are also a few makefiles that build a test
program that only uses the graphics library without any language
interpreter.  Among other things, this can be helpful in verifying that no
accidental dependencies on the interpreter have crept into the library or
drivers.

<p>
For families of similar platforms, the question arises whether to use
multiple top-level makefiles, or whether to use a single top-level makefile
that may require minor editing for some (or all) platforms.  Ghostscript
currently uses the following top-level makefiles for building interpreter
configurations:

<ul>

<li>Unix (including Linux):
<ul>
<li><a href="../src/unix-gcc.mak">src/unix-gcc.mak</a>,
for Unix with gcc.
<li><a href="../src/unixansi.mak">src/unixansi.mak</a>,
for Unix with an ANSI C compiler other than gcc.
<li><a href="../src/unixtrad.mak">src/unixtrad.mak</a>,
for Unix with a "traditional" or "K&amp;R" compiler.
</ul>

<li>PC:
<ul>
<li><a href="../src/bcwin32.mak">src/bcwin32.mak</a>,
for MS Windows with Borland C++ Builder.
<li><a href="../src/msvc32.mak">src/msvc32.mak</a>,
for MS Windows with Microsoft Visual C (MSVC).
<li><a href="../src/os2.mak">src/os2.mak</a>,
for MS-DOS or OS/2 GCC/EMX environment.
<li><a href="../src/watc.mak">src/watc.mak</a>,
for extended MS-DOS with Watcom C.
<li><a href="../src/watcw32.mak">src/watcw32.mak</a>,
for MS Windows with Watcom C.
</ul>

<li>Other:
<ul>
<li><a href="../src/all-arch.mak">src/all-arch.mak</a>,
for building on many Unix systems in a networked test environment.
<li><a href="../src/dvx-gcc.mak">src/dvx-gcc.mak</a>,
for DesqView/X with gcc.
<li><a href="../src/openvms.mak">src/openvms.mak</a>,
for OpenVMS with Digital's CC compiler and the MMS build program.
<li><a href="../src/openvms.mmk">src/openvms.mmk</a>,
for OpenVMS with Digital's CC compiler and the MMK build program.
</ul>

</ul>

<p>
The following top-level makefiles build the library test program:

<ul>
<li><a href="../src/ugcclib.mak">src/ugcclib.mak</a>,
on Unix with gcc.
<li><a href="../src/msvclib.mak">src/msvclib.mak</a>,
on MS Windows with MSVC.
<li><a href="../src/watclib.mak">src/watclib.mak</a>,
on extended MS-DOS with Watcom C.
</ul>

<p>
The MSVC makefiles may require editing to select between different versions
of MSVC, since different versions may have slightly incompatible command
line switches or customary installation path names.  The Unix makefiles
often require editing to deal with differing library path names and/or
library names.  For details, see <a href="Make.htm#Unix_build">the Unix
section</a> of the documentation for building Ghostscript.

<p>
Library test program files:
<a href="../src/gslib.c">src/gslib.c</a>.

<p>
Platform-independent makefiles:
<a href="../src/cfonts.mak">src/cfonts.mak</a>,
<a href="../src/contrib.mak">src/contrib.mak</a>,
<a href="../src/devs.mak">src/devs.mak</a>,
<a href="../src/gs.mak">src/gs.mak</a>,
<a href="../src/int.mak">src/int.mak</a>,
<a href="../src/jpeg.mak">src/jpeg.mak</a>,
<a href="../src/lib.mak">src/lib.mak</a>,
<a href="../src/libpng.mak">src/libpng.mak</a>,
<a href="../src/version.mak">src/version.mak</a>,
<a href="../src/wmin.mak">src/wmin.mak</a>,
<a href="../src/zlib.mak">src/zlib.mak</a>.

<p>
Shared platform-dependent makefiles:
<a href="../src/dvx-head.mak">src/dvx-head.mak</a>,
<a href="../src/dvx-tail.mak">src/dvx-tail.mak</a>,
<a href="../src/msvccmd.mak">src/msvccmd.mak</a>,
<a href="../src/msvctail.mak">src/msvctail.mak</a>,
<a href="../src/pcwin.mak">src/pcwin.mak</a>,
<a href="../src/unix-aux.mak">src/unix-aux.mak</a>,
<a href="../src/unix-end.mak">src/unix-end.mak</a>,
<a href="../src/unixhead.mak">src/unixhead.mak</a>,
<a href="../src/unixinst.mak">src/unixinst.mak</a>,
<a href="../src/unixlink.mak">src/unixlink.mak</a>,
<a href="../src/wccommon.mak">src/wccommon.mak</a>,
<a href="../src/wctail.mak">src/wctail.mak</a>,
<a href="../src/winint.mak">src/winint.mak</a>,
<a href="../src/winlib.mak">src/winlib.mak</a>,
<a href="../src/winplat.mak">src/winplat.mak</a>.

<h2><a name="Coding"></a>Coding</h2>

<p>
Coding for portability requires avoiding both <em>explicit</em>
dependencies, such as platform-dependent <b><tt>#ifdef</tt></b>s, and
<em>implicit</em> dependencies, such as dependencies on byte order or the
size of the integral types.

<h3><a name="Explicit_dependencies"></a>Explicit dependencies</h3>

<p>
The platform-independent .c files never, ever, use <b><tt>#ifdef</tt></b> or
<b><tt>#if</tt></b> to select code for specific platforms.  Instead, we
always try to characterize some abstract property that is being tested.  For
example, rather than checking for macros that are defined on those specific
platforms that have 64-bit <b><tt>long</tt></b> values, we define a macro
<b><tt>ARCH_SIZEOF_LONG</tt></b> that can then be tested.  Such macros are
always defined in a .h file, either automatically in <b><tt>arch.h</tt></b>,
or explicitly in a <em>xxx</em><b><tt>_.h</tt></b> file, as described in
earlier sections.

<p>
Files:
<a href="../src/std.h">src/std.h</a>,
<a href="../src/stdpre.h">src/stdpre.h</a>.

<h3><a name="Implicit_dependencies"></a>Implicit dependencies</h3>

<p>
The most common source of byte ordering dependencies is casting between
types (T1 *) and (T2 *) where T1 and T2 are numeric types that aren't merely
signed/unsigned variants of each other.  To avoid this, the only casts
allowed in the code are between numeric types, from a pointer type to a long
integral type, and between pointer types.

<p>
Ghostscript's code assumes the following about the sizes of various types:

<dl>
<dt>char<dd>8 bits
<dt>short<dd>16 bits
<dt>int<dd>32 or 64 bits
<dt>long<dd>32 or 64 bits
<dt>float<dd>32 bits (may work with 64 bits)
<dt>double<dd>64 bits (may work with 128 bits)
</dl>

<p>
The code does not assume that the <b><tt>char</tt></b> type is signed (or
unsigned); except for places where the value is always a literal string, or
for interfacing to library procedures, the code uses <b><tt>byte</tt></b> (a
Ghostscript synonym for <b><tt>unsigned char</tt></b>) almost everywhere.

<p>
Pointers are signed on some platforms and unsigned on others.  In the few
places in the memory manager where it's necessary to reliably order-compare
(as opposed to equality-compare) pointers that aren't known to point to the
same allocated block of memory, the code uses the
<b><tt>PTR_</tt></b><em>relation</em> macros rather than direct comparisons.

<p>
See the files listed above for other situations where a macro provides
platform-independence or a workaround for bugs in specific compilers or
libraries (of which there are a distressing number).

<hr>

<h1><a name="Adding_features_and_options"></a>Adding features and options</h1>

<p>
[Ray, please supply more information about what you want here]

<!-- [2.0 end contents] ==================================================== -->

<!-- [3.0 begin visible trailer] =========================================== -->
<hr>

<font size=2>

<p>Copyright &copy; 2000 artofcode LLC.  All rights reserved.

<p>This file is part of AFPL Ghostscript.  See the <a
href="Public.htm">Aladdin Free Public License</a> (the "License") for full
details of the terms of using, copying, modifying, and redistributing
AFPL Ghostscript.

<p>
Ghostscript version 6.60, 16 October 2000

</font>

<!-- [3.0 end visible trailer] ============================================= -->

</body>
</html>
