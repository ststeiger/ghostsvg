%    Copyright (C) 2000 Aladdin Enterprises.  All rights reserved.
% 
% This file is part of Aladdin Ghostscript.
% 
% Aladdin Ghostscript is distributed with NO WARRANTY OF ANY KIND.  No author
% or distributor accepts any responsibility for the consequences of using it,
% or for whether it serves any particular purpose or works at all, unless he
% or she says so in writing.  Refer to the Aladdin Ghostscript Free Public
% License (the "License") for full details.
% 
% Every copy of Aladdin Ghostscript must include a copy of the License,
% normally in a plain ASCII text file named PUBLIC.  The License grants you
% the right to copy, modify and redistribute Aladdin Ghostscript, but only
% under certain conditions described in the License.  Among other things, the
% License requires that the copyright notice and this notice be preserved on
% all copies.

% $Id$
% Implementation of ReusableStreamDecode filter.
% This file must be loaded after gs_lev2.ps and gs_res.ps.

level2dict begin

% We need LanguageLevel 2 or higher in order to have defineresource.
languagelevel dup 2 max .setlanguagelevel

% ------ ReusableStreamDecode filter ------ %

/.reusablestreamdecode {	% <source> <dict> .reusablestreamdecode <file>
				% <source> .reusablestreamdecode <file>
		% Collect the filter parameters.
  dup type /dicttype eq { 2 copy } { dup 0 dict } ifelse
  dup .rsdparams
		% Construct the filter pipeline.
		% The very first filter should use the value of CloseSource
		% from the RSD dictionary; all the others should have
		% CloseSource = true.
		% Stack: source dict filters parms
  2 index /CloseSource .knownget not { false } if 5 -1 roll
		% Stack: dict filters parms CloseSource source
  0 1 5 index length 1 sub {
    4 index 1 index get
		% Stack: dict filters parms CloseSource source index filtname
    4 index null eq {
      0 dict
    } {
      4 index 2 index get dup null eq { pop } if
    } ifelse
    3 -1 roll pop exch filter
    exch pop true exch		% set CloseSource for further filters
  } for
		% See if we can create the filter directly.
		% Stack: dict filters parms CloseSource file
  null 2 index { .reusablestream } .internalstopped {
    pop pop
		% No luck.  Read the entire contents of the stream now.
    dup type /filetype ne {
		% Make a stream from a procedure or string data source.
      0 () .subfiledecode
    } if
    10 dict exch {
		% Stack: dict filters parms CloseSource contdict file
      dup 1000 string readstring
      3 index dup length 4 -1 roll put not { exit } if
    } loop pop
		% Concatenate the contents into one big string.
		% Stack: dict filters parms CloseSource contdict
    0 1 index { length exch pop add } forall
    .bigstring exch {
		% Stack: dict filters parms CloseSource string index substring
      exch 1000 mul exch 2 index 3 1 roll putinterval
    } forall
		% Now create the stream on the string.
    null 2 index .reusablestream
  } if
		% We created the stream successfully: clean up.
  4 { exch pop } repeat
  1 index type /dicttype eq { exch pop } if exch pop
} odef

filterdict /ReusableStreamDecode /.reusablestreamdecode load put

.setlanguagelevel

end			% level2dict
