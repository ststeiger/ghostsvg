%!PS-Adobe-2.0
%
%    Copyright (C) 2002 artofcode LLC.  All rights reserved.
% 
% This software is provided AS-IS with no warranty, either express or
% implied.
% 
% This software is distributed under license and may not be copied,
% modified or distributed except as expressly authorized under the terms
% of the license contained in the file LICENSE in this distribution.
% 
% For more information about licensing, please refer to
% http://www.ghostscript.com/licensing/. For information on
% commercial licensing, go to http://www.artifex.com/licensing/ or
% contact Artifex Software, Inc., 101 Lucas Valley Road #110,
% San Rafael, CA  94903, U.S.A., +1(415)492-9861.

% $Id$
% pdfread.ps - A procset for interpreting an ordered PDF 1.3 file.

% This module is defines routines for interpreting a PDF file with
% a Postscript interpreter. To convert a PDF fine into Postscript 
% just pre-contcatenate this file. The PDF file must satisfy 
% few constraints :
%
% 1. It must contain only Postscript level 2 objects encoded with
% the PDF 1.3 language. Higher PDF levels must be re-distilled
% with CompatibilityLevel=1.3 .
%
% 2. The object must be ordered so as any resource used in a page must
% be defined before the page.
%
% 3. The PDF file must not include other PDF files.
% Consequently we have a single instance of the PDF reader.
% We use this fact to simplify binding of the routines.
% 
% 4. The PDF root object must have the object id 1.
% 
% 5. No generations besides 0 are allowed.
%
% 6. The currentfile isn't positionable.
% As a consequence, it fully ignores xref.
% xref must be at the end of the PDF file.



% !!!!!!!!!!!!!  THIS REVISION IS INCOMPLETE !!!!!!!!!!!!!!!!!!!!
% It only reads a PDF, but it does not do any attempt to interprete it.


true setglobal
30 dict begin

/DefaultSwitch  % <name> DefaultSwitch -
{
  dup where {
    pop pop
  } {
    false def
  } ifelse
} bind def

/=string 256 string def

/=only {
  //=string cvs print
} bind def

/PDFR_DEBUG DefaultSwitch
/PDFR_DUMP DefaultSwitch

/PDFReader currentdict def
/ObjectRegistry 50 array def % may grow later
/CurrentObject null def

/error  %  mark <object> .... error -
{ % A stub for a while.
  counttomark 1 sub -1 0 {
    index =only
  } for
  (\nostack contains :) =
  cleartomark
  pstack
  quit
} bind def

/Register % <DefaultDaemon> <id> <obj> Register -
{
  exch dup															% d obj id id
  //PDFReader /ObjectRegistry get length gt {
    //PDFReader /ObjectRegistry get length dup dup 2 div add array  % d obj id length []
    dup 3 1 roll                                                    % d obj id [] length []
    exch 0 exch getinterval                                         % d obj id [] []
    //PDFReader /ObjectRegistry get exch copy pop                   % d obj id []
    //PDFReader /ObjectRegistry exch put                            % d obj id
  } if
  exch //PDFReader /ObjectRegistry get								% d id obj r
  3 1 roll															% d r id obj
  3 copy pop get													% d r id obj e
  dup xcheck {														% d r id obj e
    5 4 roll pop													% r id obj e
	% We've got a definition daemon, execute it :
	exec
  } {																% d r id obj e
      dup null ne {													% d r id obj e
		mark (The object ) 4 index ( already defined : ) 4 index //error exec
	} {
	  pop
    } ifelse
	4 3 roll														% r id obj d
	% Execute the default daemon :
	exec
  } ifelse															% r id obj
  put																%
} bind def

/GetRegistered % <id> GetRegistered <obj>
{
  //PDFReader /ObjectRegistry get									% id r
  dup length														% id r l
  2 index le {														% id r
    exch mark exch (Object ) exch ( isn't defined before needed (1).) //error exec 
  } if
  1 index get														% id e
  dup xcheck {
    exch mark exch (Object ) exch ( isn't defined before needed (2).) //error exec 
  } { dup null eq {
		exch mark exch (Object ) exch ( isn't defined before needed (3).) //error exec 
      } if
	  exch pop														% e
  } ifelse

} bind def

/ContextDaemon
{ % The default context daemon does nothing.
} bind def

/R % <id> <gen> R <daemon>
{ % Make a reference daemon.
  0 ne {
    exch mark exch (A referred object generation ) exch ( isn't 0.) //error exec
  } if																% id
  [ % <id> proc <obj>
    exch //GetRegistered /exec load /ContextDaemon cvx
  ] cvx
  PDFR_DEBUG {
    ({ ) print
	dup {
	  =only ( ) print
	} forall
    ( }) =
  } if
} bind def

/DoNothing 
{
} def

/obj % <id> <generation> obj <id>
{
  PDFR_DEBUG {
	(Defining ) print 1 index =only ( ) print dup =only ( obj) =
  } if
  0 ne {
    exch mark exch (An object generation ) exch ( isn't 0.) //error exec
  } if
} bind def

/endobj  % <id> <obj> endobj -
{
  PDFR_DEBUG {
	(Storing ) print 1 index =
  } if
  //DoNothing 3 1 roll //Register exec
} bind def

/BlockBuffer 4096 string def

/StoreBlock % <buf> StoreBlock -
{ % Stores a (encoded) stream data block to the current object.
  PDFR_DEBUG {
	(StoreBlock ) print //PDFReader /BlockCount get =only (, Length = ) print dup length =
  } if
  dup length string copy
  //PDFReader /BlockCount get exch									% i s
  //PDFReader /CurrentObject get 3 1 roll							% o i s
  put																%
  //PDFReader /BlockCount get 1 add
  //PDFReader exch /BlockCount exch put
} bind def

/CheckLength % <val> CheckNumber <val>
{ dup type /integertype ne {
    mark (Object length isn't an integer.) //error exec
  } if
} bind def

/UnRefD % <dict> <key> <check> UnRefD <value>
{
  3 copy pop get                                                    % <> key {} e
  dup xcheck {
    % We've got a reference daemon, execute it :
	exec															% <> key {} val
  } if
  exch exec															% <> key val
  dup 4 1 roll														% val <> key val
  put																% val
} bind def

/StoreStream  % <id> <obj> StoredStream <id> <obj>
{ % Stores a (encoded) data stream copy to the current object.
  dup //PDFReader exch /CurrentObject exch put						% id obj
  //PDFReader /BlockCount 0 put
  dup /Length //CheckLength //UnRefD exec							% id obj l
  PDFR_DEBUG {
	(StoreStream Length = ) print dup =
  } if
  currentfile exch () /SubFileDecode filter							% id obj file
  {	dup //BlockBuffer readstring {							        % id obj file buf
	  //StoreBlock exec
    } {
	  //StoreBlock exec
	  exit
	} ifelse														% id obj file
  } loop
  pop																% id obj
  //PDFReader /CurrentObject null put
  PDFR_DEBUG {
	(StoreStream end.) =
  } if
} bind def

/stream  % <id> <obj> stream <id> <obj>
{
  //StoreStream exec
} bind def


/endstream % <id> <obj> endstream <id> <obj>
{ % Nothing to do.
} bind def

/xref % - xref -
{ 
  PDFR_DEBUG {
    (xref) =
	PDFR_DUMP {
	  //PDFReader /ObjectRegistry get ==
    } if
  } if
  end % The procset
  count 0 ne {
	mark (Excessive data on estack at the end of the interpretation.) //error exec
  } if
  currentfile flushfile
} bind def

% Leaving the procset on the dictionary stack.
%%EndPrologue
