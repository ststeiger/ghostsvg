%    Copyright (C) 2000 artofcode LLC.  All rights reserved.
% 
% This software is provided AS-IS with no warranty, either express or
% implied.
% 
% This software is distributed under license and may not be copied,
% modified or distributed except as expressly authorized under the terms
% of the license contained in the file LICENSE in this distribution.
% 
% For more information about licensing, please refer to
% http://www.ghostscript.com/licensing/. For information on
% commercial licensing, go to http://www.artifex.com/licensing/ or
% contact Artifex Software, Inc., 101 Lucas Valley Road #110,
% San Rafael, CA  94903, U.S.A., +1(415)492-9861.

% $Id$
% Redefine Font and CIDFont categories with FAPI-handeled fonts.

.FAPIavailable not {
  currentfile closefile
} if

languagelevel 2 .setlanguagelevel

%========================= Process xlatmap ====================
{ % We convert it into a plain text to simplify the processing in C :
  % *(fontkind\0\0\ *(charmap\0decoding\0) ) \0
  mark
  (xlatmap) .runlibfile
  ()
  {                              % mark name array ... string
    1 index mark eq {
      exch pop exit
    } if
    2 index =string cvs concatstrings (\0\0) concatstrings
    3 2 roll pop exch            % mark ... string array
    dup length 1 sub 0 exch 2 exch
    {                            % mark ... string array i
      2 copy get                 % mark ... string array i cmap
      4 3 roll exch concatstrings (\0) concatstrings 
                                 % mark ... array i string
      2 index 3 2 roll 1 add get % mark ... array string DecodingName
      =string cvs concatstrings (\0) concatstrings
                                 % mark ... array string
      exch                       % mark ... string array
    } for
    pop                          % mark ... string
  } loop                         % string
  (\0) concatstrings
  systemdict exch /.xlatmap exch put
} bind exec


%====================================================================
% Redefine Font category with FAPIfontmap and CIDFont with FAPIfontmap :
15 dict begin    % a temporary dictionary for local binding.

/EmbedFontObjectsQuery mark
  /.EmbedFontObjects 0
.dicttomark def

/is_device_compatible_to_FAPI    % - is_device_compatible_to_FAPI <bool>
{ currentdevice //EmbedFontObjectsQuery .getdeviceparams               % <mark> <name> <value> ...
  dup mark eq {
    pop true
  } {
    exch pop exch pop 0 eq
  } ifelse
  % The code above assumes that only the requested parameter is rendered.
  % The commented-out code below may be useful for general case.
  % Keeping it for a while.
  % counttomark 2 idiv {
  %   exch /.EmbedFontObjects eq {
  %     counttomark 1 add 1 roll cleartomark
  %     0 eq exit
  %   } if
  % } repeat
  % dup mark eq {
  %   pop true
  % } if
} bind def

%----------------------------- Process FAPIconfig -----------------------

/Config
<<
  (FAPIconfig) .runlibfile
>> def

/RefinePath      % /key RefinePath -
{ Path .path_is_absolute not {
    /Path //Config 2 index get pssystemparams /GenericResourcePathSep get 
    Path concatstrings concatstrings def
  } if
  pop
} bind def

%-------------------------------Font--------------------------------

/FontCommon  % - font_common -
{ currentdict /PaintType known not {
    /PaintType 0 def
  } if
  
  currentdict /Encoding .knownget not {
    //StandardEncoding
  } if
  dup type /nametype eq {
    /Encoding findresource
  } if
  /Encoding exch def

  /FontPath //RefinePath exec

} bind def

/FontOptions 5 dict begin
  /make_procs currentdict def
  /NameKey /FontName def
  /TypeKey /FontType def

  1
  { /FontMatrix [0.001 0 0 0.001 0 0] def
    /FontBBox [-128 -128 1024 1024] def % zfapi.ps refines it.
    /Private 0 dict def
    /CharStrings << /.notdef () >> def
    //FontCommon exec
  } bind def

  42
  { /FontMatrix [1 0 0 1 0 0] def
    /FontBBox [0 0 1 1] def % zfapi.ps refines it.
    /CharStrings <<>> def
    /sfnts [<00010000 0000 0000 0000 0000 0000>] def
    /GlyphDirectory [] def
    //FontCommon exec
  } bind def

  %fixme : more font types.

currentdict end def


%---------------------------CIDFont---------------------------

/TranslateCSI   % <record> TranslateCSI <CSI>
{ begin
  << /Registry (Adobe) 
     /Ordering CSI aload pop 
     /Supplement exch 
  >>
  end
} bind def

/CIDFontCommon
{ /CIDSystemInfo currentdict //TranslateCSI exec def
  currentdict /CSI undef
  /CIDFontPath //RefinePath exec
  /FontBBox [-128 -128 1024 1024] def % zfapi.ps refines it.
  /CIDCount 1 def % FAPI_choose_decoding will set a reasonable value.
} bind def

% GFlyph substitution table for narrow, wide, proportional glyphs - 
% used with TrueTypes.

currentpacking false setpacking
/SubstNWP << 

  % Array format : orig_type, beg_CID, end_CID, subst_beg_CID, subst_type
  % type = (n==narrow, w==wide, p==proportional).

  /Japan1
  { p 1 94 231 n    

    p 17 26 780 w
    p 34 59 790 w
    p 66 91 816 w
    w 842 842 7918 w  % fixme: These substitutions require to shift the glyph origin.
    w 844 844 7919 w
    w 846 846 7920 w
    w 848 848 7921 w
    w 850 850 7922 w
    w 876 876 7923 w
    w 908 908 7924 w
    w 910 910 7925 w
    w 912 912 7926 w
    w 914 914 7927 w
    w 925 925 7928 w
    w 927 927 7929 w
    w 929 929 7930 w
    w 931 931 7931 w
    w 933 933 7932 w
    w 959 959 7933 w
    w 991 991 7934 w
    w 993 993 7935 w
    w 995 995 7936 w
    w 1002 1002 7937 w
    w 1009 1009 7938 w
    w 1010 1010 7939 w
  } cvlit

  /Japan2 1 index

  /CNS1
  { p 1 94 13648 n

    p 17 26 333 w
    p 34 59 365 w
    p 66 91 391 w
  } cvlit

  /GB1
  { p 2 94 814 n
  
    p 2 94 262 w

    p 1 1 7716 n
  } cvlit

  /Korea1
  { p  1 60 8094 n
    p 62 94 8155 n

    p  2 59 264 w
    p 63 94 325 w
  } cvlit

>> def
setpacking

/CIDFontOptions 5 dict begin
  /make_procs currentdict def
  /NameKey /CIDFontName def
  /TypeKey /CIDFontType def

  0
  { //CIDFontCommon exec
    /FDArray [
      14 dict begin
        /FontName CIDFontName =string cvs (%) concatstrings cvn def
        /FontType 1 def
        /FontMatrix [0.001 0 0 0.001 0 0 ] def
        /PaintType 0 def
        /Private 0 dict def
        currentdict
      end
    ] def
    /GlyphDirectory [] def
    /GDBytes 1 def
    /FDBytes 0 def
  } bind def

  1
  { //CIDFontCommon exec
    /FontMatrix [1 0 0 1 0 0] def
    /BuildGlyph {} def
  } bind def

  2
  { //CIDFontCommon exec
    /FontMatrix [1 0 0 1 0 0] def
    /GDBytes 2 def
    /CIDMap <0000> def
    /sfnts [<00010000 0000 0000 0000 0000 0000>] def
    /Encoding [] def
    /CharStrings << /.notdef 0 >> def
  } bind def

currentdict end def

%---------------------------common----------------------------

/complete_instance  % <font_name> <FontDict> <Options> complete_FAPI_Font <font_name> <FontDict>
{ begin
  dup length dict copy
  begin
  1 index NameKey exch def
  currentglobal true setglobal
  make_procs TypeKey load .knownget {
    exec
  } { setglobal
      /complete_instance cvx /invalidfont signalerror
  } ifelse
  setglobal
  currentdict end
  end
} bind def

/IsMyRecord      % <raw_record> -> <raw_record> bool
{ dup type /dicttype eq { dup /FAPI known } { false } ifelse
} bind def

/GetFilePath    % <scratch> <Name> <record> GetFilePath <filepath>
{ exch pop                       % (scratch) <record>
  /Path get                      % (scratch) (path)
  exch copy
  % Actually it is not a PS resource - unable to provide full conformity :
  % the attempt to run this file may fail.
} bind def

/GetSize        % <Name> <record> GetSize <size>
{ pop pop -1 % Unknown size.
  % fixme: probably we could provide an estimation size for some fonts.
} bind def

/IsActive       % <record> IsActive <bool>
{ pop //is_device_compatible_to_FAPI exec
} bind def

/FontRecordVirtualMethods 3 dict begin
  /GetFilePath //GetFilePath def
  /GetSize //GetSize def
  /IsActive //IsActive def
  /MakeInstance   % <Name> <record> MakeInstance <Name> <Instance> <size>
  { //FontOptions //complete_instance exec
    2 copy //GetSize exec
  } bind def
currentdict end def

/CIDFontRecordVirtualMethods 3 dict begin
  /GetFilePath //GetFilePath def
  /GetSize //GetSize def
  /GetCSI //TranslateCSI def
  /IsActive //IsActive def
  /MakeInstance   % <Name> <record> MakeInstance <Name> <Instance> <size>
  { //CIDFontOptions //complete_instance exec
    2 copy //GetSize exec
  } bind def
currentdict end def

%----------------------------------The Redefintion---------------------

/MappedCategoryRedefiner /ProcSet findresource /Redefine get /Redefine exch def

% Redefine the /Font category :
4 dict begin
  /CategoryName /Font def
  /MapFileName (FAPIfontmap) def
  /VerifyMap  { pop } bind def
  /PreprocessRecord  % <map> <Name> <raw_record> PreprocessRecord <map> <Name> <record> <bool>
  { //IsMyRecord exec dup {
      pop dup /RecordVirtualMethods //FontRecordVirtualMethods put
      true
    } if
  } bind def
currentdict end Redefine

% Redefine the /CIDFont category :
4 dict begin
  /CategoryName /CIDFont def
  /MapFileName (FAPIcidfmap) def
  /VerifyMap  { pop } bind def
  /PreprocessRecord  % <map> <Name> <raw_record> PreprocessRecord <map> <Name> <record> <bool>
  { //IsMyRecord exec dup {
      pop dup /RecordVirtualMethods //CIDFontRecordVirtualMethods put
      true
    } if
  } bind def
currentdict end Redefine

%==================== A hook for buildfont* operators ====================

% The procedure .FAPIhook redirects PS fonts to FAPI on necessity.
% This depends on the following conditions :
%
% 1. If font dictionary has /FAPI entry, it is a font listed in FAPIconfig.FontPath,
%    and must be build with .FAPIrebuildfont, or a copy of a font, which was
%    built with .FAPIrebuildfont .
%
% 2. If the font dictionary has /PathLoad entry, and has no /FAPI entry,
%    it is an installed PS font, which is described in lib/fontmap or
%    in GS_FONTPATH. .loadfont inserts /PathLoad entry for this case
%    (see gs_fonts.ps).
%
%    Installed fonts are being loaded with GS font loader,
%    the they are passed to FAPI is same way as embedded fonts are.
%    We do so because UFST cannot read fonts, which don't
%    follow Type 1/42 file format strongly.
%
% 3. Executing .loadfont, we place /FAPI_hook_disable in the 0th
%    element of some procedure on the execution stack - see gs_fonts.ps .
%    If FAPI_hook finds /FAPI_hook_disable in there, 
%    it knows that it is called for a disk font during 
%    its internal definefont.
%
% 4. If font dictionary has no /FAPI entry, and has no /Path entry,
%    and if we are not in .loadfont context, it is an embedded font.
%
% 5. Two entries to be defined in lib/FAPIconfig to control the hooking of PS fonts :
%    Hook_Disk_Fonts and Hook_Embedded_Fonts .
%    They specify arrays of font types (integers) to be redirected with FAPI.
%    Hook_Disk_Fonts controls disk PS fonts (which fall into (2) and (3) ).
%    Hook_Embedded_Fonts controls fonts being embedded into documents.
%
% 7. We apply the operator .passtoFAPI for checking whether FAPI can handle a font. 
%    If so, we insert /FAPI entry into the font dictionary and convert it
%    with .FAPIrebuildfont . Otherwise the font is handled with the native GS font renderer.

/FAPI_hook_debug   % <proc> FAPI_hook_debug -
DEBUG { {exec} } { {pop} } ifelse
bind def
 
/FAPI_hook_warn   % <proc> FAPI_hook_debug -
QUIET { {pop} } { {exec} } ifelse
bind def
 
/encodingnames mark
 StandardEncoding /StandardEncoding
 ISOLatin1Encoding /ISOLatin1Encoding
 SymbolEncoding /SymbolEncoding
 DingbatsEncoding /DingbatsEncoding
 /resourceforall where
  { pop (*) { cvn dup findencoding exch } 100 string /Encoding resourceforall }
 if
.dicttomark def

/FAPI_choose_decoding  % <font> FAPI_choose_decoding <font>
{ { % A loop for 'exit' context.
    dup /Decoding .knownget {
      dup type /nametype eq {
        1 index /CIDFontType known { /CIDDecoding } { /Decoding } ifelse
        findresource 1 index exch /Decoding exch put
      } {
        pop
      } ifelse
      dup /CIDFontType known {
        dup dup /Decoding get /CIDCount get /CIDCount exch put
      } if
      exit
    } if
    dup /CIDFontType known {
      % This is a hooked CID font, no need for Decoding.
      exit
    } if
    % This works when the renderer can't choose character by name,
    % and we cannot determine the charset.
    % Probably this branch is to be removed later.
    dup /Encoding get                                    % <<font>> encoding
    dup type /nametype eq {
      /Decoding findresource 1 index exch /Decoding exch put
    } {
      dup //encodingnames
      exch .knownget {
        exch pop
        /Decoding findresource 1 index exch /Decoding exch put
      } {
        % unknown encoding, convert it to decoding :
        dup length dict begin
        /.notdef 0 def
        0 1 currentdict length 1 sub
        { dup 2 index exch get 
          dup /.notdef ne {
            exch def
          } {
            pop pop
          } ifelse
        } for
        pop
        currentdict end
        1 index exch /Decoding exch put
      } ifelse
    } ifelse
    exit
  } loop
  dup /SubstNWP .knownget {
    //SubstNWP exch get                                  % <<font>> [SubstNWP]
    1 index exch /SubstNWP exch put
  } if
} bind def

/FAPI_is_hook_disabled     % - FAPI_is_hook_disabled <bool>
{ % checks whether execution stack contains packedarray started with /FAPI_hook_disable .
  /FAPI_hook_disable /MappedCategoryRedefiner /ProcSet findresource /execstack_lookup get exec
  null ne
} bind def

/PrintFontRef      % <string|name> <font> PrintFontRef <string|name> <font>
{ dup /FontName known { (Font ) } { (CIDFont ) } ifelse print
  1 index =string cvs print
  dup /FontName .knownget not {
    dup /CIDFontName get
  } if                               % <string|name> <font> <fontname>
  dup 3 index ne {
    ( \( aliased from ) print
    =string cvs print ( \)) print
  } {
    pop
  } ifelse
} bind def

/FindInArray    % <array> <elem> .array_find <bool>
{ false 3 1 roll
  exch {                      % false elem elem_i
    1 index eq {              % false elem
       pop true exch
    } if
  } forall
  pop
} bind def

/GetFontType       % <font> GetType int
{ dup /CIDFontType .knownget {
    exch pop 9 add
  } {
    /FontType get
  } ifelse
} bind def

/FAPIhook_aux  %      <string|name> <font_dict> .FAPIhook <string|name> <font>
{                                                     % name <<font>>
  { (FAPIhook ) print 1 index = } //FAPI_hook_debug exec
  dup /FAPI known {
    { //PrintFontRef exec ( is mapped to FAPI=) print dup /FAPI get = } //FAPI_hook_warn exec
    true //.FAPIrebuildfont //FAPI_choose_decoding exec
  } {
    dup /PathLoad known dup {
      { (PathLoad known for the font ) print //PrintFontRef exec (.) = } //FAPI_hook_debug exec
    } {
      pop //FAPI_is_hook_disabled exec dup
      { pop
        { (FAPIhook is in .loadfont context for the font ) print //PrintFontRef exec (.) = } //FAPI_hook_debug exec
        true
      } if
    } ifelse
    { /HookDiskFonts } { /HookEmbeddedFonts } ifelse
    //Config exch get                                  % name <<font>> [types]
    1 index //GetFontType exec //FindInArray exec      % name <<font>> bHook
    { { (Trying to render the font ) print //PrintFontRef exec ( with FAPI...) = } //FAPI_hook_debug exec
      //.FAPIpassfont {
        { //PrintFontRef exec ( is being rendered with FAPI=) print dup /FAPI get = } //FAPI_hook_warn exec
        false //.FAPIrebuildfont //FAPI_choose_decoding exec
      } {
        { (Can't render ) print //PrintFontRef exec ( with FAPI, will do with native GS renderer.) = } //FAPI_hook_warn exec
      } ifelse
    } {
      { (The font ) print //PrintFontRef exec ( doesn't need to render with FAPI.) = } //FAPI_hook_debug exec
    } ifelse
  } ifelse
} bind def

/FAPIhook  %      <string|name> <font_dict> .FAPIhook <string|name> <font>
{ //is_device_compatible_to_FAPI exec
  { //FAPIhook_aux exec
  } {
    { (FAPIhook is disabled for the current device.) = } //FAPI_hook_debug exec
  } ifelse
} bind def

% Redefine .buildfont* with FAPI :
/.buildfont1
{ //.buildfont1 exec //FAPIhook exec
} bind % 'odef' is below.

/.buildfont2
{ //.buildfont2 exec //FAPIhook exec
} bind % 'odef' is below.

/.buildfont42
{ //.buildfont42 exec //FAPIhook exec
} bind % 'odef' is below.

/.buildfont9
{ //.buildfont9 exec //FAPIhook exec
} bind % 'odef' is below.

/.buildfont10
{ //.buildfont10 exec //FAPIhook exec
} bind % 'odef' is below.

/.buildfont11
{ //.buildfont11 exec //FAPIhook exec
} bind % 'odef' is below.

end
odef odef odef odef odef odef

.setlanguagelevel

