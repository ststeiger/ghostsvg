%    Copyright (C) 2000 artofcode LLC.  All rights reserved.
% 
% This software is provided AS-IS with no warranty, either express or
% implied.
% 
% This software is distributed under license and may not be copied,
% modified or distributed except as expressly authorized under the terms
% of the license contained in the file LICENSE in this distribution.
% 
% For more information about licensing, please refer to
% http://www.ghostscript.com/licensing/. For information on
% commercial licensing, go to http://www.artifex.com/licensing/ or
% contact Artifex Software, Inc., 101 Lucas Valley Road #110,
% San Rafael, CA  94903, U.S.A., +1(415)492-9861.

% $Id$
% Redefine CIDFont category with an emulation with True Type fonts.

languagelevel 2 .setlanguagelevel

15 dict begin    % a temporary dictionary for local binding.

%------------------Copy the FontEmulationProcs here : -------------------

/FontEmulationProcs /ProcSet findresource {
  def
} forall

currentdict /super.complete_instance currentdict /complete_instance get put

%-------Auxiliary procedures for building CIDFontType 2 from TT file -----------

/put_to_CIDMap    % <cid> <gid> [CIDmap] put_to_CIDMap <cid> 
{                                       % cid gid []
  2 index 2 mul exch                    % cid gid i []
  {                                     % cid gid i ()
    dup length dup                      % cid gid i () l l
    3 index lt {                        % cid gid i () l
      exch pop sub                      % cid gid i'
    } {                                 % cid gid i () l
      pop exch                          % cid gid () i
      3 2 roll                          % cid () i gid
      3 copy 256 idiv put               % cid () i gid
      exch 1 add exch 256 mod put       % cid
      dup dup exit                      % cid cid cid
    } ifelse
  } forall                              % cid ? ?
  pop pop                               % cid
} bind def

/GenerateCIDMap   % <font> GenerateCIDMap <font>
{
  (GenerateCIDMap : Incomplete implementation. See lib/gs_cidtt.ps .) =
  begin

    % Obtain the maximal CID :
    %   fixme : this incomplete implementation doesn't check whether glyphs really present.
    Decoding /CIDCount get /CIDCount exch def

    % Prepare the CIDMap structure :
    /CIDMap [
      CIDCount 32767 le {
                % Use a single string.
        CIDCount 2 mul string
      } {
                % We must use 2 strings.
        32767 2 mul string
        CIDCount 32767 sub 2 mul string
      } ifelse
    ] def

    % Now build it :
    %   fixme : account SubstNWP. See zfapi.c .
    %   fixme : C code would be faster. 
    Decoding {
      exch                                   % [dec] key
      dup type /integertype eq {             % [dec] cidHigh
        256 mul                              % [dec] cid
        exch {                               % cid value
          dup type /integertype eq {
            exch                             % cc cid
            TT_cmap % fixme : optimize.
            dup length                       % cc cid [cmap] l
            2 index le {                     % cc cid [cmap]
              pop exch pop                   % cid
            } {                              % cc cid [cmap]
              3 2 roll                       % cid [cmap] cc
              dup 2 index length lt {
                get                          % cid gid
                CIDMap % fixme : optimize    % cid gid [CIDmap]
                //put_to_CIDMap exec         % cid
              } {
                pop pop
              } ifelse
            } ifelse
          } {
            pop                              % cid
          } ifelse                           
          1 add                              % cid'
        } forall
        pop                                  %
      } {
        pop pop                              %
      } ifelse
    } forall  
  currentdict end
} bind def

/load_sfnts  % <FontDict> load_sfnts <FontDict> 
{ % Read the True Type file from the path /Path, and buld /sfnts,
  % skipping glyf and loca. 
  dup /Path get                                            % <font> (path)
  QUIET not {
    (Loading a TT font from ) print dup print 
    ( to emulate a CID font ) print 1 index /CIDFontName get =only ( ... ) print
  } if
  (r) file dup                                             % <font> file file
  3 1 roll                                                 % file <font> file
  1 index /SubfontID .knownget not { 0 } if                % file <font> file SubfontID
  .load_tt_font_stripped exch copy                         % file <font>
  QUIET not {
    (Done.) =
  } if
  dup 3 1 roll                                             % <font> file <font>
  exch /File exch put                                      % <font>
  dup dup /CIDSystemInfo get /Ordering get (.)             % <font> () ()
  2 index /Decoding get =string cvs                        % <font> () () ()
  concatstrings concatstrings cvn /Decoding exch put       % <font>
  //ChooseDecoding exec                                    % <font>
  //GenerateCIDMap exec                                    % <font>
} bind def

%-----------TrueType-specific methods for category redefinition : -----------

/RefinePath      % <FontDict> RefinePath <FontDict>
{ dup begin
  Path .pathstring_not_bare not {	% only add prefix is path is bare
    % See how Fontmap fonts are being located. Use same procedure.
    (Resolve a relative path to a True Type font : Incomplete implementation. See lib/gs_cidtt.ps .) =
    /RefinePath cvx /invalidfont .signalerror
  } if
  pop
  currentdict end
} bind def

/complete_instance  % <font_name> <FontDict> <Options> complete_FAPI_Font <font_name> <FontDict>
{ 1 index /CIDFontType 2 put % Other types are not emulated yet.
  //super.complete_instance exec
  //RefinePath exec
  //load_sfnts exec
} bind def

/IsMyRecord      % <raw_record> -> <raw_record> bool
{ dup type /dicttype eq { dup /FileType .knownget { /TrueType eq } { false } ifelse } { false } ifelse
} bind def

/IsActive       % <record> IsActive <bool>
{ pop true
} bind def

/CIDFontRecordVirtualMethods //RecordVirtualMethodsStub dup length 3 add dict copy begin
  /GetCSI //TranslateCSI def
  /IsActive //IsActive def
  /MakeInstance   % <Name> <record> MakeInstance <Name> <Instance> <size>
  { //CIDFontOptions //complete_instance exec
    2 copy //GetSize exec
  } bind def
currentdict end def

% Redefine the /CIDFont category :
4 dict begin
  /CategoryName /CIDFont def
  /MapFileName (cidttmap) def
  /IsMapFileOptional true def
  /VerifyMap  { pop } bind def
  /PreprocessRecord  % <map> <Name> <raw_record> PreprocessRecord <map> <Name> <record> <bool>
  { //IsMyRecord exec dup {
      pop dup /RecordVirtualMethods //CIDFontRecordVirtualMethods put
      true
    } if
  } bind def
currentdict end

/MappedCategoryRedefiner /ProcSet findresource /Redefine get exec

end  % the temporary dictionary for local binding.

.setlanguagelevel
