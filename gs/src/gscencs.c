/* Copyright (C) 2002 Aladdin Enterprises.  All rights reserved.
  
  This software is provided AS-IS with no warranty, either express or
  implied.
  
  This software is distributed under license and may not be copied,
  modified or distributed except as expressly authorized under the terms
  of the license contained in the file LICENSE in this distribution.
  
  For more information about licensing, please refer to
  http://www.ghostscript.com/licensing/. For information on
  commercial licensing, go to http://www.artifex.com/licensing/ or
  contact Artifex Software, Inc., 101 Lucas Valley Road #110,
  San Rafael, CA  94903, U.S.A., +1(415)492-9861.
*/

/* $Id$ */
/* Compact C representation of built-in encodings */

#include "memory_.h"
#include "gscencs.h"

/*
 * The actual encoding data tables in gscedata.c are generated by encs2c.c.
 *
 * gscedata.c defines the following macros:
 *	MAX_DIRECT_LEN -- the maximum length of a name in the "direct"
 *	  section of the tables.
 *	NUM_INDIRECT_LEN -- the number of indirect lengths = the maximum
 *	  length of a name - MAX_DIRECT_LEN.
 *	NUM_CHARS -- the total number of characters in the character table.
 *	I_<name> -- the encoded representation of the name <name>.
 */

/*
 * In the encoding tables in this file, each glyph is represented by a
 * ushort (16-bit) value.  A bias of gs_c_min_std_encoding_glyph is added
 * or subtracted to form a gs_glyph value.
 *
 * The 16-bit encoded values are computed as L * NUM_CHARS + P.
 * If the length of the name is less than or equal to MAX_DIRECT_LEN,
 * L is the length of the name - 1, and P is the offset of the first
 * character of the name in the character table.  Note that this allows
 * a glyph to share name characters with other glyphs: this reduces the
 * size of the character table significantly.
 */

#define N(len,offset) (((len) - 1) * NUM_CHARS + (offset))
#define N_LEN(e) ((e) / NUM_CHARS + 1)
#define N_OFFSET(e) ((e) % NUM_CHARS)

/*
 * If the length of the name is greater than MAX_DIRECT_LEN,
 * L is MAX_DIRECT_LEN, and P = I * NUM_INDIRECT_LEN + M,
 * where M is the length of the name minus (MAX_DIRECT_LEN + 1) and
 * I is the index of the name within the section of the character table
 * reserved for names of that specific length.
 */

#define NX(len,index)\
  N(MAX_DIRECT_LEN+1, (index) * NUM_INDIRECT_LEN + (len) - (MAX_DIRECT_LEN+1))
#define NX_LEN(off) ((off) % NUM_INDIRECT_LEN + (MAX_DIRECT_LEN+1))
#define NX_INDEX(off) ((off) / NUM_INDIRECT_LEN)

/*
 * Since many characters in many encodings map to .notdef, we trade a
 * little time for a significant space saving by storing each encoding as
 * a series of runs of (M * .notdef, N * not .notdef).
 */

#define C(nnotd,nd) ((ushort)(((nnotd) << 9) + (nd)))
#define C_NNOTDEF(c) ((c) >> 9)
#define C_NDEF(c) ((c) & 0x1ff)

/*
 * gscedata.c defines the following tables:
 *	static const char gs_c_std_encoding_chars[NUM_CHARS] --
 *	  the character table.
 *	static const int gs_c_std_encoding_offsets[NUM_INDIRECT_LEN] --
 *	  the starting offsets of the names of a given length in the
 *	  character table.
 *	static const ushort gs_c_std_encoding_<i>[] --
 *	  the representations of the individual encodings.
 *	static const ushort *const gs_c_std_encodings[] --
 *	  pointers to c_std_encoding_<i>.
 *	static const ushort gs_c_sorted_short[] --
 *	  sorted glyph indices that reuse characters of other names.
 *	static const uint gs_c_sorted_starts[] --
 *	  the starting offsets of the per-length sections in sorted_short.
 */

#include "gscedata.c"

const gs_glyph gs_c_min_std_encoding_glyph = gs_min_cid_glyph - 0x10000;

/*
 * Encode a character in a known encoding.  The only use for glyph numbers
 * returned by this procedure is to pass them to gs_c_glyph_name.
 */
gs_glyph
gs_c_known_encode(gs_char ch, int ei) {
    const ushort *ep;
    int i, nd;

    if (ei < 0 || ei >= countof(gs_c_std_encodings) - 1)
	return gs_no_glyph;
    for (ep = gs_c_std_encodings[ei], i = ch; *ep; ep += 1 + nd, i -= nd) {
	if ((i -= C_NNOTDEF(*ep)) < 0)
	    return I__notdef + gs_c_min_std_encoding_glyph;
	nd = C_NDEF(*ep);
	if (i < nd)
	    return ep[1+i] + gs_c_min_std_encoding_glyph;
    }
    return gs_no_glyph;
}

/*
 * Convert a glyph number returned by gs_c_known_encode to a string.
 */
const char *
gs_c_glyph_name(gs_glyph g, uint *plen) {
    uint n = (uint)(g - gs_c_min_std_encoding_glyph);
    uint len = N_LEN(n), offset = N_OFFSET(n);

    if (len <= MAX_DIRECT_LEN) {
	*plen = len;
	return &gs_c_std_encoding_chars[offset];
    } else {
	uint lenx = NX_LEN(offset);

	*plen = lenx;
	return &gs_c_std_encoding_chars[gs_c_std_encoding_offsets[lenx] +
				       NX_INDEX(offset) * lenx];
    }
}
int
gs_c_glyph_name2(gs_glyph g, gs_const_string *pstr, void *proc_data)
{
    pstr->data = (const byte *)gs_c_glyph_name(g, &pstr->size);
    return 0;
}

/*
 * Return the glyph number corresponding to a string (the inverse of
 * gs_c_glyph_name), or gs_no_glyph if the glyph name is not known.
 */
gs_glyph
gs_c_name_glyph(const char *str, uint len)
{
    byte ch0;

    if (len == 0 || len > MAX_DIRECT_LEN + NUM_INDIRECT_LEN)
	return gs_no_glyph;
    /*
     * Search the main character table linearly, starting with an
     * intelligent first probe.
     */
    {
	const byte *bot = (const byte *)
	    &gs_c_std_encoding_chars[gs_c_std_encoding_offsets[len]];
	const byte *top = (const byte *)
	    &gs_c_std_encoding_chars[gs_c_std_encoding_offsets[len - 1]];

	ch0 = (byte)str[0];
	if (bot < top && ch0 >= bot[0] && ch0 <= top[-len]) {
	    const byte *probe = bot + (top - bot) * (ch0 - bot[0]) /
		(top[-len] - bot[0] + 1) / len * len;

#define RET_N(l, p)\
  return gs_c_min_std_encoding_glyph +\
    ((l) <= MAX_DIRECT_LEN ? N(l, (p) - (const byte *)gs_c_std_encoding_chars) :\
     NX(l, ((p) - bot) / (l)))

	    if (ch0 >= probe[0]) {
		/* Scan upward. */
		for (; probe < top; probe += len)
		    if (probe[0] == ch0) {
			int cmp = memcmp(probe, str, len);

			if (cmp == 0)
			    RET_N(len, probe);
			else if (cmp > 0)
			    break;
		    }
	    }
	    if (ch0 <= probe[0]) {
		/* Scan downward. */
		for (; probe >= bot; probe -= len)
		    if (probe[0] == ch0) {
			int cmp = memcmp(probe, str, len);

			if (cmp == 0)
			    RET_N(len, probe);
			else if (cmp < 0)
			    break;
		    }
	    }
#undef RET_N
	}
    }
    if (len > MAX_DIRECT_LEN)
	return gs_no_glyph;
    /*
     * Search the auxiliary table similarly.  All of its entries are for
     * short names.
     */
    {
	const ushort *bot = &gs_c_sorted_short[gs_c_sorted_starts[len]];
	const ushort *top = &gs_c_sorted_short[gs_c_sorted_starts[len - 1]];
	byte bot0, top0;

	if (bot < top && ch0 >= (bot0 = (byte)gs_c_std_encoding_chars[N_OFFSET(bot[0])]) &&
	    ch0 <= (top0 = (byte)gs_c_std_encoding_chars[N_OFFSET(top[-1])])
	    ) {
	    const ushort *probe = bot + (top - bot) * (ch0 - bot0) /
		(top0 - bot0 + 1);
	    byte p0 = (byte)gs_c_std_encoding_chars[N_OFFSET(*probe)];

	    if (ch0 >= p0) {
		/* Scan upward. */
		for (; probe < top; ++probe) {
		    int cmp =
			memcmp(&gs_c_std_encoding_chars[N_OFFSET(*probe)],
			       str, len);

		    if (cmp == 0)
			return gs_c_min_std_encoding_glyph + *probe;
		    else if (cmp > 0)
			break;
		}
	    }
	    if (ch0 <= p0) {
		/* Scan downward. */
		for (; probe >= bot; --probe) {
		    int cmp =
			memcmp(&gs_c_std_encoding_chars[N_OFFSET(*probe)],
			       str, len);

		    if (cmp == 0)
			return gs_c_min_std_encoding_glyph + *probe;
		    else if (cmp < 0)
			break;
		}
	    }
	}
    }

    return gs_no_glyph;
}

#ifdef TEST

/* Test */
#include <stdio.h>
main()
{
    gs_glyph g;
    const char *s;
    uint len;

    /* Test with a short name. */
    g = gs_c_known_encode((gs_char)0237, 1); /* caron */
    printf("caron is %u, should be %u\n",
	   g - gs_c_min_std_encoding_glyph, I_caron);
    s = gs_c_glyph_name(g, &len);
    fwrite(s, 1, len, stdout);
    printf(" should be caron\n");

    /* Test with a long name. */
    g = gs_c_known_encode((gs_char)0277, 2); /* carriagereturn */
    printf("carriagereturn is %u, should be %u\n",
	   g - gs_c_min_std_encoding_glyph, I_carriagereturn);
    s = gs_c_glyph_name(g, &len);
    fwrite(s, 1, len, stdout);
    printf(" should be carriagereturn\n");

    /* Test lookup with 3 kinds of names. */
    g = gs_c_name_glyph("circlemultiply", 14);
    printf("circlemultiply is %u, should be %u\n",
	   g - gs_c_min_std_encoding_glyph, I_circlemultiply);
    g = gs_c_name_glyph("numbersign", 10);
    printf("numbersign is %u, should be %u\n",
	   g - gs_c_min_std_encoding_glyph, I_numbersign);
    g = gs_c_name_glyph("copyright", 9);
    printf("copyright is %u, should be %u\n",
	   g - gs_c_min_std_encoding_glyph, I_copyright);

    exit(0);
}

#endif /* TEST */
